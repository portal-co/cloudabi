<!DOCTYPE html>
<html>
	<head>
		<title>Nuxi CloudABI</title>
		<meta charset="UTF-8">
		<link rel="stylesheet" type="text/css" href="https://nuxi.nl/style.css">
		<link rel="shortcut icon" type="image/png" href="https://nuxi.nl/img/favicon.png">
		<style>
html, body {
	font-size: 16px;
}

p {
	text-align: left;
}

a[name] {
	position: relative;
}

a[name]::before {
	position: absolute;
	display: block;
}

a[name]:target::before {
	content: "➥";
	right: 1em;
	transform: scale(2);
}

h4 > a[name]:not(:target):first-child::before,
li > p:first-child > a[name]:not(:target):first-child::before {
	content: "\00a0";
	right: 0;
	padding: 0 1em;
}

h4:hover > a[name]:not(:target):first-child::before,
li > p:first-child:hover > a[name]:not(:target):first-child::before {
	content: "§";
	transform: none;
	right: 0;
	top: -0.5em;
	padding: 0.5em 1em;
}

h1, h2, h3, h4 {
	font-weight: normal;
	margin-bottom: 10px;
}

h1 {
	font-size: 3.2em;
}

h2 {
	font-size: 2.4em;
}

h3 {
	font-size: 1.9em;
}

h4 {
	font-size: 1.6em;
}

pre {
	background: #eee;
	padding: 0.5em;;
}

ul p {
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	text-align: left;
}

ul p:last-child {
	margin-bottom: 0.6em;
}

ul {
	list-style: none;
	padding-left: 2em;
}

li > p + p {
	margin-left: 1.5em;
	font-size: 0.9em;
}

p + ul {
	margin-top: -0.5em;
}

ul p + ul {
	margin-top: 0em;
	padding-left: 3em;
}

ul p:first-child + ul{
	margin-top: 0;
}
		</style>
	</head>
	<body>
		<div class="topbox">
			<a href="https://nuxi.nl/"><img src="https://nuxi.nl/img/logo.svg" alt="Nuxi"/></a>
		</div>

		<div class="contentbox-light">
<!--
Copyright (c) 2016-2019 Nuxi (https://nuxi.nl/) and contributors.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.

This file is automatically generated. Do not edit.

Source: https://github.com/NuxiNL/cloudabi
-->

<h1>Nuxi CloudABI</h1>

<p>CloudABI is what you get if you take POSIX, add capability-based
security, and remove everything that's incompatible with that. The
result is a minimal ABI consisting of only 49 syscalls.</p>

<p>CloudABI doesn't have its own kernel, but instead is implemented in existing
kernels: FreeBSD has CloudABI support for x86-64 and arm64, and <a href="https://github.com/NuxiNL/netbsd">a patch-set
for NetBSD</a> and <a href="https://github.com/NuxiNL/linux">a patch-set for
Linux</a> are available as well. This means that
CloudABI binaries can be executed on different operating systems, without any
modification.</p>

<h2>Capability-Based Security</h2>

<p>Capability-based security means that processes can only perform
actions that have no global impact. Processes cannot open files by
their absolute path, cannot open network connections, and cannot
observe global system state such as the process table.</p>

<p>The capabilities of a process are fully determined by its set of open
file descriptors (fds). For example, files can only be opened if the
process already has a file descriptor to a directory the file is in.</p>

<p>Unlike in POSIX, where processes are normally started with file
descriptors 0, 1, and 2 reserved for standard input, output, and
error, CloudABI does not reserve any file descriptor numbers for
specific purposes.</p>

<p>In CloudABI, a process depends on its parent process to launch it with
the right set of resources, since the process will not be able to open
any new resources. For example, a simple static web server would need
to be started with a file descriptor to a <a href="https://github.com/NuxiNL/flower">TCP
listener</a>, and a file descriptor to
the directory for which to serve files. The web server will then be
unable to do anything other than reading files in that directory, and
process incoming network connections.</p>

<p>So, unknown CloudABI binaries can safely be executed without the need
for containers, virtual machines, or other sandboxing technologies.</p>

<p>Watch <a href="https://www.youtube.com/watch?v=3N29vrPoDv8">Ed Schouten's Talk at
32C3</a> for more
information about what capability-based security for UNIX means.</p>

<h2>Cloudlibc</h2>

<p><a href="https://github.com/NuxiNL/cloudlibc">Cloudlibc</a> is an implementation
of the C standard library, without all CloudABI-incompatible
functions. For example, Cloudlibc does not have <code>printf</code>, but does
have <code>fprintf</code>. It does not have <code>open</code>, but does have <code>openat</code>.</p>

<h2>CloudABI-Ports</h2>

<p><a href="https://github.com/NuxiNL/cloudabi-ports">CloudABI-Ports</a> is a
collection of ports of commonly used libraries and applications to
CloudABI. It contains software such as <code>zlib</code>, <code>libpng</code>, <code>boost</code>,
<code>memcached</code>, and much more. The software is patched to not depend on
any global state, such as files in <code>/etc</code> or <code>/dev</code>, using <code>open()</code>,
etc.</p>

<h2>Using CloudABI</h2>

<p>Instructions for using CloudABI (including kernel modules/patches,
toolchain, and ports) are available for several operating systems:</p>

<ul>
<li><a href="https://cloudabi.org/run/freebsd/">FreeBSD</a></li>
<li><a href="https://cloudabi.org/run/linux/">Linux</a></li>
<li><a href="https://cloudabi.org/run/macos/">macOS</a></li>
</ul>

<h2>Specification of the ABI</h2>

<p>The entire ABI is specified in a file called
<a href="https://github.com/NuxiNL/cloudabi/blob/master/cloudabi.txt"><code>cloudabi.txt</code></a>,
from which all
<a href="https://github.com/NuxiNL/cloudabi/tree/master/headers">headers</a>
and documentation (including the one you're reading now) is generated.</p>

<h3>System calls</h3>

<ul>
<li><a href="#clock_res_get"><code>clock_res_get()</code></a></li>
<li><a href="#clock_time_get"><code>clock_time_get()</code></a></li>
<li><a href="#condvar_signal"><code>condvar_signal()</code></a></li>
<li><a href="#fd_close"><code>fd_close()</code></a></li>
<li><a href="#fd_create1"><code>fd_create1()</code></a></li>
<li><a href="#fd_create2"><code>fd_create2()</code></a></li>
<li><a href="#fd_datasync"><code>fd_datasync()</code></a></li>
<li><a href="#fd_dispatch"><code>fd_dispatch()</code></a></li>
<li><a href="#fd_dup"><code>fd_dup()</code></a></li>
<li><a href="#fd_pread"><code>fd_pread()</code></a></li>
<li><a href="#fd_pwrite"><code>fd_pwrite()</code></a></li>
<li><a href="#fd_read"><code>fd_read()</code></a></li>
<li><a href="#fd_replace"><code>fd_replace()</code></a></li>
<li><a href="#fd_seek"><code>fd_seek()</code></a></li>
<li><a href="#fd_stat_get"><code>fd_stat_get()</code></a></li>
<li><a href="#fd_stat_put"><code>fd_stat_put()</code></a></li>
<li><a href="#fd_sync"><code>fd_sync()</code></a></li>
<li><a href="#fd_write"><code>fd_write()</code></a></li>
<li><a href="#file_advise"><code>file_advise()</code></a></li>
<li><a href="#file_allocate"><code>file_allocate()</code></a></li>
<li><a href="#file_create"><code>file_create()</code></a></li>
<li><a href="#file_link"><code>file_link()</code></a></li>
<li><a href="#file_open"><code>file_open()</code></a></li>
<li><a href="#file_readdir"><code>file_readdir()</code></a></li>
<li><a href="#file_readlink"><code>file_readlink()</code></a></li>
<li><a href="#file_rename"><code>file_rename()</code></a></li>
<li><a href="#file_stat_fget"><code>file_stat_fget()</code></a></li>
<li><a href="#file_stat_fput"><code>file_stat_fput()</code></a></li>
<li><a href="#file_stat_get"><code>file_stat_get()</code></a></li>
<li><a href="#file_stat_put"><code>file_stat_put()</code></a></li>
<li><a href="#file_symlink"><code>file_symlink()</code></a></li>
<li><a href="#file_unlink"><code>file_unlink()</code></a></li>
<li><a href="#lock_unlock"><code>lock_unlock()</code></a></li>
<li><a href="#mem_advise"><code>mem_advise()</code></a></li>
<li><a href="#mem_map"><code>mem_map()</code></a></li>
<li><a href="#mem_protect"><code>mem_protect()</code></a></li>
<li><a href="#mem_sync"><code>mem_sync()</code></a></li>
<li><a href="#mem_unmap"><code>mem_unmap()</code></a></li>
<li><a href="#poll"><code>poll()</code></a></li>
<li><a href="#proc_exec"><code>proc_exec()</code></a></li>
<li><a href="#proc_exit"><code>proc_exit()</code></a></li>
<li><a href="#proc_fork"><code>proc_fork()</code></a></li>
<li><a href="#proc_raise"><code>proc_raise()</code></a></li>
<li><a href="#random_get"><code>random_get()</code></a></li>
<li><a href="#sock_recv"><code>sock_recv()</code></a></li>
<li><a href="#sock_send"><code>sock_send()</code></a></li>
<li><a href="#sock_shutdown"><code>sock_shutdown()</code></a></li>
<li><a href="#thread_create"><code>thread_create()</code></a></li>
<li><a href="#thread_exit"><code>thread_exit()</code></a></li>
<li><a href="#thread_yield"><code>thread_yield()</code></a></li>
</ul>

<h4><a href="#clock_res_get" name="clock_res_get"></a><code>clock_res_get()</code></h4>

<p>Obtains the resolution of a clock.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#clock_res_get.clock_id" name="clock_res_get.clock_id"></a><code><strong>clock_id</strong>: <a href="#clockid">clockid</a></code></p>

<p>The clock for which the resolution needs to be
returned.</p></li>
</ul>

<p>Outputs:</p>

<ul>
<li><p><a href="#clock_res_get.resolution" name="clock_res_get.resolution"></a><code><strong>resolution</strong>: <a href="#timestamp">timestamp</a></code></p>

<p>The resolution of the clock.</p></li>
</ul>

<h4><a href="#clock_time_get" name="clock_time_get"></a><code>clock_time_get()</code></h4>

<p>Obtains the time value of a clock.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#clock_time_get.clock_id" name="clock_time_get.clock_id"></a><code><strong>clock_id</strong>: <a href="#clockid">clockid</a></code></p>

<p>The clock for which the time needs to be
returned.</p></li>
<li><p><a href="#clock_time_get.precision" name="clock_time_get.precision"></a><code><strong>precision</strong>: <a href="#timestamp">timestamp</a></code></p>

<p>The maximum lag (exclusive) that the returned
time value may have, compared to its actual
value.</p></li>
</ul>

<p>Outputs:</p>

<ul>
<li><p><a href="#clock_time_get.time" name="clock_time_get.time"></a><code><strong>time</strong>: <a href="#timestamp">timestamp</a></code></p>

<p>The time value of the clock.</p></li>
</ul>

<h4><a href="#condvar_signal" name="condvar_signal"></a><code>condvar_signal()</code></h4>

<p>Wakes up threads waiting on a userspace condition variable.</p>

<p>If an invocation of this system call causes all waiting
threads to be woken up, the value of the condition variable
is set to <a href="#condvar.has_no_waiters"><code>CONDVAR_HAS_NO_WAITERS</code></a>. As long as the condition
variable is set to this value, it is not needed to invoke this
system call.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#condvar_signal.condvar" name="condvar_signal.condvar"></a><code><strong>condvar</strong>: *mut <a href="#condvar">condvar</a></code></p>

<p>The userspace condition variable that has
waiting threads.</p></li>
<li><p><a href="#condvar_signal.scope" name="condvar_signal.scope"></a><code><strong>scope</strong>: <a href="#scope">scope</a></code></p>

<p>Whether the condition variable is stored in
private or shared memory.</p></li>
<li><p><a href="#condvar_signal.nwaiters" name="condvar_signal.nwaiters"></a><code><strong>nwaiters</strong>: <a href="#nthreads">nthreads</a></code></p>

<p>The number of threads that need to be woken
up. If it exceeds the number of waiting
threads, all threads are woken up.</p></li>
</ul>

<h4><a href="#fd_close" name="fd_close"></a><code>fd_close()</code></h4>

<p>Closes a file descriptor.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#fd_close.fd" name="fd_close.fd"></a><code><strong>fd</strong>: <a href="#fd">fd</a></code></p>

<p>The file descriptor that needs to be closed.</p></li>
</ul>

<h4><a href="#fd_create1" name="fd_create1"></a><code>fd_create1()</code></h4>

<p>Creates a file descriptor.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#fd_create1.type" name="fd_create1.type"></a><code><strong>r#type</strong>: <a href="#filetype">filetype</a></code></p>

<p>Possible values:</p>

<ul>
<li><p><a href="#filetype.shared_memory"><code>SHARED_MEMORY</code></a></p>

<p>Creates an anonymous shared memory
object.</p></li>
</ul></li>
</ul>

<p>Outputs:</p>

<ul>
<li><p><a href="#fd_create1.fd" name="fd_create1.fd"></a><code><strong>fd</strong>: <a href="#fd">fd</a></code></p>

<p>The file descriptor that has been created.</p></li>
</ul>

<h4><a href="#fd_create2" name="fd_create2"></a><code>fd_create2()</code></h4>

<p>Creates a pair of file descriptors.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#fd_create2.type" name="fd_create2.type"></a><code><strong>r#type</strong>: <a href="#filetype">filetype</a></code></p>

<p>Possible values:</p>

<ul>
<li><p><a href="#filetype.socket_dgram"><code>SOCKET_DGRAM</code></a></p>

<p>Creates a UNIX datagram socket pair.</p></li>
<li><p><a href="#filetype.socket_stream"><code>SOCKET_STREAM</code></a></p>

<p>Creates a UNIX byte-stream socket
pair.</p></li>
</ul></li>
</ul>

<p>Outputs:</p>

<ul>
<li><p><a href="#fd_create2.fd1" name="fd_create2.fd1"></a><code><strong>fd1</strong>: <a href="#fd">fd</a></code></p>

<p>The first file descriptor of the pair.</p></li>
<li><p><a href="#fd_create2.fd2" name="fd_create2.fd2"></a><code><strong>fd2</strong>: <a href="#fd">fd</a></code></p>

<p>The second file descriptor of the pair.</p></li>
</ul>

<h4><a href="#fd_datasync" name="fd_datasync"></a><code>fd_datasync()</code></h4>

<p>Synchronizes the data of a file to disk.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#fd_datasync.fd" name="fd_datasync.fd"></a><code><strong>fd</strong>: <a href="#fd">fd</a></code></p>

<p>The file descriptor of the file whose data
needs to be synchronized to disk.</p></li>
</ul>

<h4><a href="#fd_dispatch" name="fd_dispatch"></a><code>fd_dispatch()</code></h4>

<p>Creates a file descriptor from a dispatcher, which is sent events about what happens on the resulting fd</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#fd_dispatch.control" name="fd_dispatch.control"></a><code><strong>control</strong>: <a href="#fd">fd</a></code></p>

<p>The descriptor to have events sent to</p></li>
</ul>

<p>Outputs:</p>

<ul>
<li><p><a href="#fd_dispatch.real" name="fd_dispatch.real"></a><code><strong>real</strong>: <a href="#fd">fd</a></code></p>

<p>The descriptor whose behavior is sent to <code>control</code></p></li>
</ul>

<h4><a href="#fd_dup" name="fd_dup"></a><code>fd_dup()</code></h4>

<p>Duplicates a file descriptor.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#fd_dup.from" name="fd_dup.from"></a><code><strong>from</strong>: <a href="#fd">fd</a></code></p>

<p>The file descriptor that needs to be
duplicated.</p></li>
</ul>

<p>Outputs:</p>

<ul>
<li><p><a href="#fd_dup.fd" name="fd_dup.fd"></a><code><strong>fd</strong>: <a href="#fd">fd</a></code></p>

<p>The new file descriptor.</p></li>
</ul>

<h4><a href="#fd_pread" name="fd_pread"></a><code>fd_pread()</code></h4>

<p>Reads from a file descriptor, without using and updating the
file descriptor's offset.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#fd_pread.fd" name="fd_pread.fd"></a><code><strong>fd</strong>: <a href="#fd">fd</a></code></p>

<p>The file descriptor from which data should be
read.</p></li>
<li><p><a href="#fd_pread.iovs" name="fd_pread.iovs"></a><code><strong>iovs</strong>: *const <a href="#iovec">iovec</a></code> and <a href="#fd_pread.iovs_len" name="fd_pread.iovs_len"></a><code><strong>iovs_len</strong>: usize</code></p>

<p>List of scatter/gather vectors where data
should be stored.</p></li>
<li><p><a href="#fd_pread.offset" name="fd_pread.offset"></a><code><strong>offset</strong>: <a href="#filesize">filesize</a></code></p>

<p>The offset within the file at which reading
should start.</p></li>
</ul>

<p>Outputs:</p>

<ul>
<li><p><a href="#fd_pread.nread" name="fd_pread.nread"></a><code><strong>nread</strong>: usize</code></p>

<p>The number of bytes read.</p></li>
</ul>

<h4><a href="#fd_pwrite" name="fd_pwrite"></a><code>fd_pwrite()</code></h4>

<p>Writes to a file descriptor, without using and updating the
file descriptor's offset.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#fd_pwrite.fd" name="fd_pwrite.fd"></a><code><strong>fd</strong>: <a href="#fd">fd</a></code></p>

<p>The file descriptor to which data should be
written.</p></li>
<li><p><a href="#fd_pwrite.iovs" name="fd_pwrite.iovs"></a><code><strong>iovs</strong>: *const <a href="#ciovec">ciovec</a></code> and <a href="#fd_pwrite.iovs_len" name="fd_pwrite.iovs_len"></a><code><strong>iovs_len</strong>: usize</code></p>

<p>List of scatter/gather vectors where data
should be retrieved.</p></li>
<li><p><a href="#fd_pwrite.offset" name="fd_pwrite.offset"></a><code><strong>offset</strong>: <a href="#filesize">filesize</a></code></p>

<p>The offset within the file at which writing
should start.</p></li>
</ul>

<p>Outputs:</p>

<ul>
<li><p><a href="#fd_pwrite.nwritten" name="fd_pwrite.nwritten"></a><code><strong>nwritten</strong>: usize</code></p>

<p>The number of bytes written.</p></li>
</ul>

<h4><a href="#fd_read" name="fd_read"></a><code>fd_read()</code></h4>

<p>Reads from a file descriptor.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#fd_read.fd" name="fd_read.fd"></a><code><strong>fd</strong>: <a href="#fd">fd</a></code></p>

<p>The file descriptor from which data should be
read.</p></li>
<li><p><a href="#fd_read.iovs" name="fd_read.iovs"></a><code><strong>iovs</strong>: *const <a href="#iovec">iovec</a></code> and <a href="#fd_read.iovs_len" name="fd_read.iovs_len"></a><code><strong>iovs_len</strong>: usize</code></p>

<p>List of scatter/gather vectors where data
should be stored.</p></li>
</ul>

<p>Outputs:</p>

<ul>
<li><p><a href="#fd_read.nread" name="fd_read.nread"></a><code><strong>nread</strong>: usize</code></p>

<p>The number of bytes read.</p></li>
</ul>

<h4><a href="#fd_replace" name="fd_replace"></a><code>fd_replace()</code></h4>

<p>Atomically replaces a file descriptor by a copy of another
file descriptor.</p>

<p>Due to the strong focus on thread safety, this environment
does not provide a mechanism to duplicate a file descriptor to
an arbitrary number, like dup2(). This would be prone to race
conditions, as an actual file descriptor with the same number
could be allocated by a different thread at the same time.</p>

<p>This system call provides a way to atomically replace file
descriptors, which would disappear if dup2() were to be
removed entirely.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#fd_replace.from" name="fd_replace.from"></a><code><strong>from</strong>: <a href="#fd">fd</a></code></p>

<p>The file descriptor that needs to be copied.</p></li>
<li><p><a href="#fd_replace.to" name="fd_replace.to"></a><code><strong>to</strong>: <a href="#fd">fd</a></code></p>

<p>The file descriptor that needs to be
overwritten.</p></li>
</ul>

<h4><a href="#fd_seek" name="fd_seek"></a><code>fd_seek()</code></h4>

<p>Moves the offset of the file descriptor.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#fd_seek.fd" name="fd_seek.fd"></a><code><strong>fd</strong>: <a href="#fd">fd</a></code></p>

<p>The file descriptor whose offset has to be
moved.</p></li>
<li><p><a href="#fd_seek.offset" name="fd_seek.offset"></a><code><strong>offset</strong>: <a href="#filedelta">filedelta</a></code></p>

<p>The number of bytes to move.</p></li>
<li><p><a href="#fd_seek.whence" name="fd_seek.whence"></a><code><strong>whence</strong>: <a href="#whence">whence</a></code></p>

<p>Relative to which position the move should
take place.</p></li>
</ul>

<p>Outputs:</p>

<ul>
<li><p><a href="#fd_seek.newoffset" name="fd_seek.newoffset"></a><code><strong>newoffset</strong>: <a href="#filesize">filesize</a></code></p>

<p>The new offset of the file descriptor,
relative to the start of the file.</p></li>
</ul>

<h4><a href="#fd_stat_get" name="fd_stat_get"></a><code>fd_stat_get()</code></h4>

<p>Gets attributes of a file descriptor.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#fd_stat_get.fd" name="fd_stat_get.fd"></a><code><strong>fd</strong>: <a href="#fd">fd</a></code></p>

<p>The file descriptor whose attributes have to
be obtained.</p></li>
<li><p><a href="#fd_stat_get.buf" name="fd_stat_get.buf"></a><code><strong>buf</strong>: *mut <a href="#fdstat">fdstat</a></code></p>

<p>The buffer where the file descriptor's
attributes are stored.</p></li>
</ul>

<h4><a href="#fd_stat_put" name="fd_stat_put"></a><code>fd_stat_put()</code></h4>

<p>Adjusts attributes of a file descriptor.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#fd_stat_put.fd" name="fd_stat_put.fd"></a><code><strong>fd</strong>: <a href="#fd">fd</a></code></p>

<p>The file descriptor whose attributes have to
be adjusted.</p></li>
<li><p><a href="#fd_stat_put.buf" name="fd_stat_put.buf"></a><code><strong>buf</strong>: *const <a href="#fdstat">fdstat</a></code></p>

<p>The desired values of the file descriptor
attributes that are adjusted.</p></li>
<li><p><a href="#fd_stat_put.flags" name="fd_stat_put.flags"></a><code><strong>flags</strong>: <a href="#fdsflags">fdsflags</a></code></p>

<p>A bitmask indicating which attributes have to
be adjusted.</p></li>
</ul>

<h4><a href="#fd_sync" name="fd_sync"></a><code>fd_sync()</code></h4>

<p>Synchronizes the data and metadata of a file to disk.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#fd_sync.fd" name="fd_sync.fd"></a><code><strong>fd</strong>: <a href="#fd">fd</a></code></p>

<p>The file descriptor of the file whose data
and metadata needs to be synchronized to disk.</p></li>
</ul>

<h4><a href="#fd_write" name="fd_write"></a><code>fd_write()</code></h4>

<p>Writes to a file descriptor.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#fd_write.fd" name="fd_write.fd"></a><code><strong>fd</strong>: <a href="#fd">fd</a></code></p>

<p>The file descriptor to which data should be
written.</p></li>
<li><p><a href="#fd_write.iovs" name="fd_write.iovs"></a><code><strong>iovs</strong>: *const <a href="#ciovec">ciovec</a></code> and <a href="#fd_write.iovs_len" name="fd_write.iovs_len"></a><code><strong>iovs_len</strong>: usize</code></p>

<p>List of scatter/gather vectors where data
should be retrieved.</p></li>
</ul>

<p>Outputs:</p>

<ul>
<li><p><a href="#fd_write.nwritten" name="fd_write.nwritten"></a><code><strong>nwritten</strong>: usize</code></p>

<p>The number of bytes written.</p></li>
</ul>

<h4><a href="#file_advise" name="file_advise"></a><code>file_advise()</code></h4>

<p>Provides file advisory information on a file descriptor.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#file_advise.fd" name="file_advise.fd"></a><code><strong>fd</strong>: <a href="#fd">fd</a></code></p>

<p>The file descriptor for which to provide file
advisory information.</p></li>
<li><p><a href="#file_advise.offset" name="file_advise.offset"></a><code><strong>offset</strong>: <a href="#filesize">filesize</a></code></p>

<p>The offset within the file to which the
advisory applies.</p></li>
<li><p><a href="#file_advise.len" name="file_advise.len"></a><code><strong>len</strong>: <a href="#filesize">filesize</a></code></p>

<p>The length of the region to which the advisory
applies.</p></li>
<li><p><a href="#file_advise.advice" name="file_advise.advice"></a><code><strong>advice</strong>: <a href="#advice">advice</a></code></p>

<p>The advice.</p></li>
</ul>

<h4><a href="#file_allocate" name="file_allocate"></a><code>file_allocate()</code></h4>

<p>Forces the allocation of space in a file.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#file_allocate.fd" name="file_allocate.fd"></a><code><strong>fd</strong>: <a href="#fd">fd</a></code></p>

<p>The file in which the space should be
allocated.</p></li>
<li><p><a href="#file_allocate.offset" name="file_allocate.offset"></a><code><strong>offset</strong>: <a href="#filesize">filesize</a></code></p>

<p>The offset at which the allocation should
start.</p></li>
<li><p><a href="#file_allocate.len" name="file_allocate.len"></a><code><strong>len</strong>: <a href="#filesize">filesize</a></code></p>

<p>The length of the area that is allocated.</p></li>
</ul>

<h4><a href="#file_create" name="file_create"></a><code>file_create()</code></h4>

<p>Creates a file of a specified type.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#file_create.fd" name="file_create.fd"></a><code><strong>fd</strong>: <a href="#fd">fd</a></code></p>

<p>The working directory at which the resolution
of the file to be created starts.</p></li>
<li><p><a href="#file_create.path" name="file_create.path"></a><code><strong>path</strong>: *const u8</code> and <a href="#file_create.path_len" name="file_create.path_len"></a><code><strong>path_len</strong>: usize</code></p>

<p>The path at which the file should be created.</p></li>
<li><p><a href="#file_create.type" name="file_create.type"></a><code><strong>r#type</strong>: <a href="#filetype">filetype</a></code></p>

<p>Possible values:</p>

<ul>
<li><p><a href="#filetype.directory"><code>DIRECTORY</code></a></p>

<p>Creates a directory.</p></li>
</ul></li>
</ul>

<h4><a href="#file_link" name="file_link"></a><code>file_link()</code></h4>

<p>Creates a hard link.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#file_link.fd1" name="file_link.fd1"></a><code><strong>fd1</strong>: <a href="#lookup">lookup</a></code></p>

<p>The working directory at which the resolution
of the source path starts.</p></li>
<li><p><a href="#file_link.path1" name="file_link.path1"></a><code><strong>path1</strong>: *const u8</code> and <a href="#file_link.path1_len" name="file_link.path1_len"></a><code><strong>path1_len</strong>: usize</code></p>

<p>The source path of the file that should be
hard linked.</p></li>
<li><p><a href="#file_link.fd2" name="file_link.fd2"></a><code><strong>fd2</strong>: <a href="#fd">fd</a></code></p>

<p>The working directory at which the resolution
of the destination path starts.</p></li>
<li><p><a href="#file_link.path2" name="file_link.path2"></a><code><strong>path2</strong>: *const u8</code> and <a href="#file_link.path2_len" name="file_link.path2_len"></a><code><strong>path2_len</strong>: usize</code></p>

<p>The destination path at which the hard link
should be created.</p></li>
</ul>

<h4><a href="#file_open" name="file_open"></a><code>file_open()</code></h4>

<p>Opens a file.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#file_open.dirfd" name="file_open.dirfd"></a><code><strong>dirfd</strong>: <a href="#lookup">lookup</a></code></p>

<p>The working directory at which the resolution
of the file to be opened starts.</p></li>
<li><p><a href="#file_open.path" name="file_open.path"></a><code><strong>path</strong>: *const u8</code> and <a href="#file_open.path_len" name="file_open.path_len"></a><code><strong>path_len</strong>: usize</code></p>

<p>The path of the file that should be opened.</p></li>
<li><p><a href="#file_open.oflags" name="file_open.oflags"></a><code><strong>oflags</strong>: <a href="#oflags">oflags</a></code></p>

<p>The method at which the file should be opened.</p></li>
<li><p><a href="#file_open.fds" name="file_open.fds"></a><code><strong>fds</strong>: *const <a href="#fdstat">fdstat</a></code></p>

<p><a href="#fdstat.fs_rights_base"><code>fdstat.fs_rights_base</code></a> and
<a href="#fdstat.fs_rights_inheriting"><code>fdstat.fs_rights_inheriting</code></a> specify the
initial rights of the newly created file
descriptor. The operating system is allowed to
return a file descriptor with fewer rights
than specified, if and only if those rights do
not apply to the type of file being opened.</p>

<p><a href="#fdstat.fs_flags"><code>fdstat.fs_flags</code></a> specifies the initial flags
of the file descriptor.</p>

<p><a href="#fdstat.fs_filetype"><code>fdstat.fs_filetype</code></a> is ignored.</p></li>
</ul>

<p>Outputs:</p>

<ul>
<li><p><a href="#file_open.fd" name="file_open.fd"></a><code><strong>fd</strong>: <a href="#fd">fd</a></code></p>

<p>The file descriptor of the file that has been
opened.</p></li>
</ul>

<h4><a href="#file_readdir" name="file_readdir"></a><code>file_readdir()</code></h4>

<p>Reads directory entries from a directory.</p>

<p>When successful, the contents of the output buffer consist of
a sequence of directory entries. Each directory entry consists
of a <a href="#dirent"><code>dirent</code></a> object, followed by <a href="#dirent.d_namlen"><code>dirent.d_namlen</code></a> bytes
holding the name of the directory entry.</p>

<p>This system call fills the output buffer as much as possible,
potentially truncating the last directory entry. This allows
the caller to grow its read buffer size in case it's too small
to fit a single large directory entry, or skip the oversized
directory entry.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#file_readdir.fd" name="file_readdir.fd"></a><code><strong>fd</strong>: <a href="#fd">fd</a></code></p>

<p>The directory from which to read the directory
entries.</p></li>
<li><p><a href="#file_readdir.buf" name="file_readdir.buf"></a><code><strong>buf</strong>: *mut ()</code> and <a href="#file_readdir.buf_len" name="file_readdir.buf_len"></a><code><strong>buf_len</strong>: usize</code></p>

<p>The buffer where directory entries are stored.</p></li>
<li><p><a href="#file_readdir.cookie" name="file_readdir.cookie"></a><code><strong>cookie</strong>: <a href="#dircookie">dircookie</a></code></p>

<p>The location within the directory to start
reading.</p></li>
</ul>

<p>Outputs:</p>

<ul>
<li><p><a href="#file_readdir.bufused" name="file_readdir.bufused"></a><code><strong>bufused</strong>: usize</code></p>

<p>The number of bytes stored in the read buffer.
If less than the size of the read buffer, the
end of the directory has been reached.</p></li>
</ul>

<h4><a href="#file_readlink" name="file_readlink"></a><code>file_readlink()</code></h4>

<p>Reads the contents of a symbolic link.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#file_readlink.fd" name="file_readlink.fd"></a><code><strong>fd</strong>: <a href="#fd">fd</a></code></p>

<p>The working directory at which the resolution
of the path of the symbolic starts.</p></li>
<li><p><a href="#file_readlink.path" name="file_readlink.path"></a><code><strong>path</strong>: *const u8</code> and <a href="#file_readlink.path_len" name="file_readlink.path_len"></a><code><strong>path_len</strong>: usize</code></p>

<p>The path of the symbolic link whose contents
should be read.</p></li>
<li><p><a href="#file_readlink.buf" name="file_readlink.buf"></a><code><strong>buf</strong>: *mut u8</code> and <a href="#file_readlink.buf_len" name="file_readlink.buf_len"></a><code><strong>buf_len</strong>: usize</code></p>

<p>The buffer where the contents of the symbolic
link should be stored.</p></li>
</ul>

<p>Outputs:</p>

<ul>
<li><p><a href="#file_readlink.bufused" name="file_readlink.bufused"></a><code><strong>bufused</strong>: usize</code></p>

<p>The number of bytes placed in the buffer.</p></li>
</ul>

<h4><a href="#file_rename" name="file_rename"></a><code>file_rename()</code></h4>

<p>Renames a file.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#file_rename.fd1" name="file_rename.fd1"></a><code><strong>fd1</strong>: <a href="#fd">fd</a></code></p>

<p>The working directory at which the resolution
of the source path starts.</p></li>
<li><p><a href="#file_rename.path1" name="file_rename.path1"></a><code><strong>path1</strong>: *const u8</code> and <a href="#file_rename.path1_len" name="file_rename.path1_len"></a><code><strong>path1_len</strong>: usize</code></p>

<p>The source path of the file that should be
renamed.</p></li>
<li><p><a href="#file_rename.fd2" name="file_rename.fd2"></a><code><strong>fd2</strong>: <a href="#fd">fd</a></code></p>

<p>The working directory at which the resolution
of the destination path starts.</p></li>
<li><p><a href="#file_rename.path2" name="file_rename.path2"></a><code><strong>path2</strong>: *const u8</code> and <a href="#file_rename.path2_len" name="file_rename.path2_len"></a><code><strong>path2_len</strong>: usize</code></p>

<p>The destination path to which the file should
be renamed.</p></li>
</ul>

<h4><a href="#file_stat_fget" name="file_stat_fget"></a><code>file_stat_fget()</code></h4>

<p>Gets attributes of a file by file descriptor.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#file_stat_fget.fd" name="file_stat_fget.fd"></a><code><strong>fd</strong>: <a href="#fd">fd</a></code></p>

<p>The file descriptor whose attributes have to
be obtained.</p></li>
<li><p><a href="#file_stat_fget.buf" name="file_stat_fget.buf"></a><code><strong>buf</strong>: *mut <a href="#filestat">filestat</a></code></p>

<p>The buffer where the file's attributes are
stored.</p></li>
</ul>

<h4><a href="#file_stat_fput" name="file_stat_fput"></a><code>file_stat_fput()</code></h4>

<p>Adjusts attributes of a file by file descriptor.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#file_stat_fput.fd" name="file_stat_fput.fd"></a><code><strong>fd</strong>: <a href="#fd">fd</a></code></p>

<p>The file descriptor whose attributes have to
be adjusted.</p></li>
<li><p><a href="#file_stat_fput.buf" name="file_stat_fput.buf"></a><code><strong>buf</strong>: *const <a href="#filestat">filestat</a></code></p>

<p>The desired values of the file attributes that
are adjusted.</p></li>
<li><p><a href="#file_stat_fput.flags" name="file_stat_fput.flags"></a><code><strong>flags</strong>: <a href="#fsflags">fsflags</a></code></p>

<p>A bitmask indicating which attributes have to
be adjusted.</p></li>
</ul>

<h4><a href="#file_stat_get" name="file_stat_get"></a><code>file_stat_get()</code></h4>

<p>Gets attributes of a file by path.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#file_stat_get.fd" name="file_stat_get.fd"></a><code><strong>fd</strong>: <a href="#lookup">lookup</a></code></p>

<p>The working directory at which the resolution
of the path whose attributes have to be
obtained starts.</p></li>
<li><p><a href="#file_stat_get.path" name="file_stat_get.path"></a><code><strong>path</strong>: *const u8</code> and <a href="#file_stat_get.path_len" name="file_stat_get.path_len"></a><code><strong>path_len</strong>: usize</code></p>

<p>The path of the file whose attributes have to
be obtained.</p></li>
<li><p><a href="#file_stat_get.buf" name="file_stat_get.buf"></a><code><strong>buf</strong>: *mut <a href="#filestat">filestat</a></code></p>

<p>The buffer where the file's attributes are
stored.</p></li>
</ul>

<h4><a href="#file_stat_put" name="file_stat_put"></a><code>file_stat_put()</code></h4>

<p>Adjusts attributes of a file by path.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#file_stat_put.fd" name="file_stat_put.fd"></a><code><strong>fd</strong>: <a href="#lookup">lookup</a></code></p>

<p>The working directory at which the resolution
of the path whose attributes have to be
adjusted starts.</p></li>
<li><p><a href="#file_stat_put.path" name="file_stat_put.path"></a><code><strong>path</strong>: *const u8</code> and <a href="#file_stat_put.path_len" name="file_stat_put.path_len"></a><code><strong>path_len</strong>: usize</code></p>

<p>The path of the file whose attributes have to
be adjusted.</p></li>
<li><p><a href="#file_stat_put.buf" name="file_stat_put.buf"></a><code><strong>buf</strong>: *const <a href="#filestat">filestat</a></code></p>

<p>The desired values of the file attributes that
are adjusted.</p></li>
<li><p><a href="#file_stat_put.flags" name="file_stat_put.flags"></a><code><strong>flags</strong>: <a href="#fsflags">fsflags</a></code></p>

<p>A bitmask indicating which attributes have to
be adjusted.</p></li>
</ul>

<h4><a href="#file_symlink" name="file_symlink"></a><code>file_symlink()</code></h4>

<p>Creates a symbolic link.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#file_symlink.path1" name="file_symlink.path1"></a><code><strong>path1</strong>: *const u8</code> and <a href="#file_symlink.path1_len" name="file_symlink.path1_len"></a><code><strong>path1_len</strong>: usize</code></p>

<p>The contents of the symbolic link.</p></li>
<li><p><a href="#file_symlink.fd" name="file_symlink.fd"></a><code><strong>fd</strong>: <a href="#fd">fd</a></code></p>

<p>The working directory at which the resolution
of the destination path starts.</p></li>
<li><p><a href="#file_symlink.path2" name="file_symlink.path2"></a><code><strong>path2</strong>: *const u8</code> and <a href="#file_symlink.path2_len" name="file_symlink.path2_len"></a><code><strong>path2_len</strong>: usize</code></p>

<p>The destination path at which the symbolic
link should be created.</p></li>
</ul>

<h4><a href="#file_unlink" name="file_unlink"></a><code>file_unlink()</code></h4>

<p>Unlinks a file, or removes a directory.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#file_unlink.fd" name="file_unlink.fd"></a><code><strong>fd</strong>: <a href="#fd">fd</a></code></p>

<p>The working directory at which the resolution
of the path starts.</p></li>
<li><p><a href="#file_unlink.path" name="file_unlink.path"></a><code><strong>path</strong>: *const u8</code> and <a href="#file_unlink.path_len" name="file_unlink.path_len"></a><code><strong>path_len</strong>: usize</code></p>

<p>The path that needs to be unlinked or removed.</p></li>
<li><p><a href="#file_unlink.flags" name="file_unlink.flags"></a><code><strong>flags</strong>: <a href="#ulflags">ulflags</a></code></p>

<p>Possible values:</p>

<ul>
<li><p><a href="#ulflags.removedir"><code>REMOVEDIR</code></a></p>

<p>If set, attempt to remove a directory.
Otherwise, unlink a file.</p></li>
</ul></li>
</ul>

<h4><a href="#lock_unlock" name="lock_unlock"></a><code>lock_unlock()</code></h4>

<p>Unlocks a write-locked userspace lock.</p>

<p>If a userspace lock is unlocked while having its
<a href="#lock.kernel_managed"><code>LOCK_KERNEL_MANAGED</code></a> flag set, the lock cannot be unlocked in
userspace directly. This system call needs to be performed
instead, so that any waiting threads can be woken up.</p>

<p>To prevent spurious invocations of this system call, the lock
must be locked for writing. This prevents other threads from
acquiring additional read locks while the system call is in
progress. If the lock is acquired for reading, it must first
be upgraded to a write lock.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#lock_unlock.lock" name="lock_unlock.lock"></a><code><strong>lock</strong>: *mut <a href="#lock">lock</a></code></p>

<p>The userspace lock that is locked for writing
by the calling thread.</p></li>
<li><p><a href="#lock_unlock.scope" name="lock_unlock.scope"></a><code><strong>scope</strong>: <a href="#scope">scope</a></code></p>

<p>Whether the lock is stored in private or
shared memory.</p></li>
</ul>

<h4><a href="#mem_advise" name="mem_advise"></a><code>mem_advise()</code></h4>

<p>Provides memory advisory information on a region of memory.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#mem_advise.mapping" name="mem_advise.mapping"></a><code><strong>mapping</strong>: *mut ()</code> and <a href="#mem_advise.mapping_len" name="mem_advise.mapping_len"></a><code><strong>mapping_len</strong>: usize</code></p>

<p>The pages for which to provide memory advisory
information.</p></li>
<li><p><a href="#mem_advise.advice" name="mem_advise.advice"></a><code><strong>advice</strong>: <a href="#advice">advice</a></code></p>

<p>The advice.</p></li>
</ul>

<h4><a href="#mem_map" name="mem_map"></a><code>mem_map()</code></h4>

<p>Creates a memory mapping, making the contents of a file
accessible through memory.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#mem_map.addr" name="mem_map.addr"></a><code><strong>addr</strong>: *mut ()</code></p>

<p>If <a href="#mflags.fixed"><code>FIXED</code></a> is set, specifies to which
address the file region is mapped. Otherwise,
the mapping is performed at an unused
location.</p></li>
<li><p><a href="#mem_map.len" name="mem_map.len"></a><code><strong>len</strong>: usize</code></p>

<p>The length of the memory mapping to be
created.</p></li>
<li><p><a href="#mem_map.prot" name="mem_map.prot"></a><code><strong>prot</strong>: <a href="#mprot">mprot</a></code></p>

<p>Initial memory protection options for the
memory mapping.</p></li>
<li><p><a href="#mem_map.flags" name="mem_map.flags"></a><code><strong>flags</strong>: <a href="#mflags">mflags</a></code></p>

<p>Memory mapping flags.</p></li>
<li><p><a href="#mem_map.fd" name="mem_map.fd"></a><code><strong>fd</strong>: <a href="#fd">fd</a></code></p>

<p>If <a href="#mflags.anon"><code>ANON</code></a> is set, this argument must be
<a href="#fd.map_anon_fd"><code>MAP_ANON_FD</code></a>. Otherwise, this argument
specifies the file whose contents need to be
mapped.</p></li>
<li><p><a href="#mem_map.off" name="mem_map.off"></a><code><strong>off</strong>: <a href="#filesize">filesize</a></code></p>

<p>If <a href="#mflags.anon"><code>ANON</code></a> is set, this argument must be
zero. Otherwise, this argument specifies the
offset within the file at which the mapping
starts.</p></li>
</ul>

<p>Outputs:</p>

<ul>
<li><p><a href="#mem_map.mem" name="mem_map.mem"></a><code><strong>mem</strong>: *mut ()</code></p>

<p>The starting address of the memory mapping.</p></li>
</ul>

<h4><a href="#mem_protect" name="mem_protect"></a><code>mem_protect()</code></h4>

<p>Change the protection of a memory mapping.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#mem_protect.mapping" name="mem_protect.mapping"></a><code><strong>mapping</strong>: *mut ()</code> and <a href="#mem_protect.mapping_len" name="mem_protect.mapping_len"></a><code><strong>mapping_len</strong>: usize</code></p>

<p>The pages that need their protection changed.</p></li>
<li><p><a href="#mem_protect.prot" name="mem_protect.prot"></a><code><strong>prot</strong>: <a href="#mprot">mprot</a></code></p>

<p>New protection options.</p></li>
</ul>

<h4><a href="#mem_sync" name="mem_sync"></a><code>mem_sync()</code></h4>

<p>Synchronize a region of memory with its physical storage.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#mem_sync.mapping" name="mem_sync.mapping"></a><code><strong>mapping</strong>: *mut ()</code> and <a href="#mem_sync.mapping_len" name="mem_sync.mapping_len"></a><code><strong>mapping_len</strong>: usize</code></p>

<p>The pages that need to be synchronized.</p></li>
<li><p><a href="#mem_sync.flags" name="mem_sync.flags"></a><code><strong>flags</strong>: <a href="#msflags">msflags</a></code></p>

<p>The method of synchronization.</p></li>
</ul>

<h4><a href="#mem_unmap" name="mem_unmap"></a><code>mem_unmap()</code></h4>

<p>Unmaps a region of memory.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#mem_unmap.mapping" name="mem_unmap.mapping"></a><code><strong>mapping</strong>: *mut ()</code> and <a href="#mem_unmap.mapping_len" name="mem_unmap.mapping_len"></a><code><strong>mapping_len</strong>: usize</code></p>

<p>The pages that needs to be unmapped.</p></li>
</ul>

<h4><a href="#poll" name="poll"></a><code>poll()</code></h4>

<p>Concurrently polls for the occurrence of a set of events.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#poll.in" name="poll.in"></a><code><strong>in</strong>: *const <a href="#subscription">subscription</a></code></p>

<p>The events to which to subscribe.</p></li>
<li><p><a href="#poll.out" name="poll.out"></a><code><strong>out</strong>: *mut <a href="#event">event</a></code></p>

<p>The events that have occurred.</p></li>
<li><p><a href="#poll.nsubscriptions" name="poll.nsubscriptions"></a><code><strong>nsubscriptions</strong>: usize</code></p>

<p>Both the number of subscriptions and events.</p></li>
</ul>

<p>Outputs:</p>

<ul>
<li><p><a href="#poll.nevents" name="poll.nevents"></a><code><strong>nevents</strong>: usize</code></p>

<p>The number of events stored.</p></li>
</ul>

<h4><a href="#proc_exec" name="proc_exec"></a><code>proc_exec()</code></h4>

<p>Replaces the process by a new executable.</p>

<p>Process execution in CloudABI differs from POSIX in two ways:
handling of arguments and inheritance of file descriptors.</p>

<p>CloudABI does not use string command line arguments. Instead,
a buffer with binary data is copied into the address space of
the new executable. The kernel does not enforce any specific
structure to this data, although CloudABI's C library uses it
to store a tree structure that is semantically identical to
YAML.</p>

<p>Due to the strong focus on thread safety, file descriptors
aren't inherited through close-on-exec flags. An explicit
list of file descriptors that need to be retained needs to be
provided. After execution, file descriptors are placed in the
order in which they are stored in the array. This not only
makes the execution process deterministic. It also prevents
potential information disclosures about the layout of the
original process.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#proc_exec.fd" name="proc_exec.fd"></a><code><strong>fd</strong>: <a href="#fd">fd</a></code></p>

<p>A file descriptor of the new executable.</p></li>
<li><p><a href="#proc_exec.data" name="proc_exec.data"></a><code><strong>data</strong>: *const ()</code> and <a href="#proc_exec.data_len" name="proc_exec.data_len"></a><code><strong>data_len</strong>: usize</code></p>

<p>Binary argument data that is passed on to the
new executable.</p></li>
<li><p><a href="#proc_exec.fds" name="proc_exec.fds"></a><code><strong>fds</strong>: *const <a href="#fd">fd</a></code> and <a href="#proc_exec.fds_len" name="proc_exec.fds_len"></a><code><strong>fds_len</strong>: usize</code></p>

<p>The layout of the file descriptor table after
execution.</p></li>
</ul>

<h4><a href="#proc_exit" name="proc_exit"></a><code>proc_exit()</code></h4>

<p>Terminates the process normally.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#proc_exit.rval" name="proc_exit.rval"></a><code><strong>rval</strong>: <a href="#exitcode">exitcode</a></code></p>

<p>The exit code returned by the process. The
exit code can be obtained by other processes
through <a href="#event.proc_terminate.exitcode"><code>event.union.proc_terminate.exitcode</code></a>.</p></li>
</ul>

<p>Does not return.</p>

<h4><a href="#proc_fork" name="proc_fork"></a><code>proc_fork()</code></h4>

<p>Forks the process of the calling thread.</p>

<p>After forking, a new process shall be created, having only a
copy of the calling thread. The parent process will obtain a
process descriptor. When closed, the child process is
automatically signaled with <a href="#signal.kill"><code>KILL</code></a>.</p>

<p>Outputs:</p>

<ul>
<li><p><a href="#proc_fork.fd" name="proc_fork.fd"></a><code><strong>fd</strong>: <a href="#fd">fd</a></code></p>

<p>In the parent process: the file descriptor
number of the process descriptor.</p>

<p>In the child process: <a href="#fd.process_child"><code>PROCESS_CHILD</code></a>.</p></li>
<li><p><a href="#proc_fork.tid" name="proc_fork.tid"></a><code><strong>tid</strong>: <a href="#tid">tid</a></code></p>

<p>In the parent process: undefined.</p>

<p>In the child process: the thread ID of the
initial thread of the child process.</p></li>
</ul>

<h4><a href="#proc_raise" name="proc_raise"></a><code>proc_raise()</code></h4>

<p>Sends a signal to the process of the calling thread.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#proc_raise.sig" name="proc_raise.sig"></a><code><strong>sig</strong>: <a href="#signal">signal</a></code></p>

<p>The signal condition that should be triggered.
If the signal causes the process to terminate,
its condition can be obtained by other
processes through
<a href="#event.proc_terminate.signal"><code>event.union.proc_terminate.signal</code></a>.</p></li>
</ul>

<h4><a href="#random_get" name="random_get"></a><code>random_get()</code></h4>

<p>Obtains random data from the kernel random number generator.</p>

<p>As this interface is not guaranteed to be fast, it is advised
that the random data obtained through this system call is used
as the seed for a userspace pseudo-random number generator.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#random_get.buf" name="random_get.buf"></a><code><strong>buf</strong>: *mut ()</code> and <a href="#random_get.buf_len" name="random_get.buf_len"></a><code><strong>buf_len</strong>: usize</code></p>

<p>The buffer that needs to be filled with random
data.</p></li>
</ul>

<h4><a href="#sock_recv" name="sock_recv"></a><code>sock_recv()</code></h4>

<p>Receives a message on a socket.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#sock_recv.sock" name="sock_recv.sock"></a><code><strong>sock</strong>: <a href="#fd">fd</a></code></p>

<p>The socket on which a message should be
received.</p></li>
<li><p><a href="#sock_recv.in" name="sock_recv.in"></a><code><strong>in</strong>: *const <a href="#recv_in">recv_in</a></code></p>

<p>Input parameters.</p></li>
<li><p><a href="#sock_recv.out" name="sock_recv.out"></a><code><strong>out</strong>: *mut <a href="#recv_out">recv_out</a></code></p>

<p>Output parameters.</p></li>
</ul>

<h4><a href="#sock_send" name="sock_send"></a><code>sock_send()</code></h4>

<p>Sends a message on a socket.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#sock_send.sock" name="sock_send.sock"></a><code><strong>sock</strong>: <a href="#fd">fd</a></code></p>

<p>The socket on which a message should be sent.</p></li>
<li><p><a href="#sock_send.in" name="sock_send.in"></a><code><strong>in</strong>: *const <a href="#send_in">send_in</a></code></p>

<p>Input parameters.</p></li>
<li><p><a href="#sock_send.out" name="sock_send.out"></a><code><strong>out</strong>: *mut <a href="#send_out">send_out</a></code></p>

<p>Output parameters.</p></li>
</ul>

<h4><a href="#sock_shutdown" name="sock_shutdown"></a><code>sock_shutdown()</code></h4>

<p>Shuts down socket send and receive channels.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#sock_shutdown.sock" name="sock_shutdown.sock"></a><code><strong>sock</strong>: <a href="#fd">fd</a></code></p>

<p>The socket that needs its channels shut down.</p></li>
<li><p><a href="#sock_shutdown.how" name="sock_shutdown.how"></a><code><strong>how</strong>: <a href="#sdflags">sdflags</a></code></p>

<p>Which channels on the socket need to be shut
down.</p></li>
</ul>

<h4><a href="#thread_create" name="thread_create"></a><code>thread_create()</code></h4>

<p>Creates a new thread within the current process.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#thread_create.attr" name="thread_create.attr"></a><code><strong>attr</strong>: *mut <a href="#threadattr">threadattr</a></code></p>

<p>The desired attributes of the new thread.</p></li>
</ul>

<p>Outputs:</p>

<ul>
<li><p><a href="#thread_create.tid" name="thread_create.tid"></a><code><strong>tid</strong>: <a href="#tid">tid</a></code></p>

<p>The thread ID of the new thread.</p></li>
</ul>

<h4><a href="#thread_exit" name="thread_exit"></a><code>thread_exit()</code></h4>

<p>Terminates the calling thread.</p>

<p>This system call can also unlock a single userspace lock
after termination, which can be used to implement thread
joining.</p>

<p>Inputs:</p>

<ul>
<li><p><a href="#thread_exit.lock" name="thread_exit.lock"></a><code><strong>lock</strong>: *mut <a href="#lock">lock</a></code></p>

<p>Userspace lock that is locked for writing by
the calling thread.</p></li>
<li><p><a href="#thread_exit.scope" name="thread_exit.scope"></a><code><strong>scope</strong>: <a href="#scope">scope</a></code></p>

<p>Whether the lock is stored in private or
shared memory.</p></li>
</ul>

<p>Does not return.</p>

<h4><a href="#thread_yield" name="thread_yield"></a><code>thread_yield()</code></h4>

<p>Temporarily yields execution of the calling thread.</p>

<h3>Types</h3>

<h4><a href="#advice" name="advice"></a><code>advice</code> (<code>u8</code> <code>enum</code>)</h4>

<p>File or memory access pattern advisory information.</p>

<p>Used by <a href="#file_advise"><code>file_advise()</code></a> and <a href="#mem_advise"><code>mem_advise()</code></a>.</p>

<p>Possible values:</p>

<ul>
<li><p><a href="#advice.dontneed" name="advice.dontneed"></a><strong><code>DONTNEED</code></strong></p>

<p>The application expects that it will not access the
specified data in the near future.</p></li>
<li><p><a href="#advice.noreuse" name="advice.noreuse"></a><strong><code>NOREUSE</code></strong></p>

<p>The application expects to access the specified data
once and then not reuse it thereafter.</p></li>
<li><p><a href="#advice.normal" name="advice.normal"></a><strong><code>NORMAL</code></strong></p>

<p>The application has no advice to give on its behavior
with respect to the specified data.</p></li>
<li><p><a href="#advice.random" name="advice.random"></a><strong><code>RANDOM</code></strong></p>

<p>The application expects to access the specified data
in a random order.</p></li>
<li><p><a href="#advice.sequential" name="advice.sequential"></a><strong><code>SEQUENTIAL</code></strong></p>

<p>The application expects to access the specified data
sequentially from lower offsets to higher offsets.</p></li>
<li><p><a href="#advice.willneed" name="advice.willneed"></a><strong><code>WILLNEED</code></strong></p>

<p>The application expects to access the specified data
in the near future.</p></li>
</ul>

<h4><a href="#auxtype" name="auxtype"></a><code>auxtype</code> (<code>u32</code> <code>enum</code>)</h4>

<p>Enumeration describing the kind of value stored in <a href="#auxv"><code>auxv</code></a>.</p>

<p>Possible values:</p>

<ul>
<li><p><a href="#auxtype.argdata" name="auxtype.argdata"></a><strong><code>ARGDATA</code></strong></p>

<p>Base address of the binary argument data provided to
<a href="#proc_exec"><code>proc_exec()</code></a>.</p></li>
<li><p><a href="#auxtype.argdatalen" name="auxtype.argdatalen"></a><strong><code>ARGDATALEN</code></strong></p>

<p>Length of the binary argument data provided to
<a href="#proc_exec"><code>proc_exec()</code></a>.</p></li>
<li><p><a href="#auxtype.base" name="auxtype.base"></a><strong><code>BASE</code></strong></p>

<p>Base address at which the executable is placed in
memory.</p></li>
<li><p><a href="#auxtype.canary" name="auxtype.canary"></a><strong><code>CANARY</code></strong></p>

<p>Base address of a buffer of random data that may be
used for non-cryptographic purposes, for example as a
canary for stack smashing protection.</p></li>
<li><p><a href="#auxtype.canarylen" name="auxtype.canarylen"></a><strong><code>CANARYLEN</code></strong></p>

<p>Length of a buffer of random data that may be used
for non-cryptographic purposes, for example as a
canary for stack smashing protection.</p></li>
<li><p><a href="#auxtype.ncpus" name="auxtype.ncpus"></a><strong><code>NCPUS</code></strong></p>

<p>Number of CPUs that the system this process is running
on has.</p></li>
<li><p><a href="#auxtype.null" name="auxtype.null"></a><strong><code>NULL</code></strong></p>

<p>Terminator of the auxiliary vector.</p></li>
<li><p><a href="#auxtype.pagesz" name="auxtype.pagesz"></a><strong><code>PAGESZ</code></strong></p>

<p>Smallest memory object size for which individual
memory protection controls can be configured.</p></li>
<li><p><a href="#auxtype.phdr" name="auxtype.phdr"></a><strong><code>PHDR</code></strong></p>

<p>Address of the first ELF program header of the
executable.</p></li>
<li><p><a href="#auxtype.phnum" name="auxtype.phnum"></a><strong><code>PHNUM</code></strong></p>

<p>Number of ELF program headers of the executable.</p></li>
<li><p><a href="#auxtype.pid" name="auxtype.pid"></a><strong><code>PID</code></strong></p>

<p>Identifier of the process.</p>

<p>This environment does not provide any simple numerical
process identifiers, for the reason that these are not
useful in distributed contexts. Instead, processes are
identified by a UUID.</p>

<p>This record should point to sixteen bytes of binary
data, containing a version 4 UUID (fully random).</p></li>
<li><p><a href="#auxtype.sysinfo_ehdr" name="auxtype.sysinfo_ehdr"></a><strong><code>SYSINFO_EHDR</code></strong></p>

<p>Address of the ELF header of the vDSO.</p>

<p>The vDSO is a shared library that is mapped in the
address space of the process. It provides entry points
for every system call supported by the environment,
all having a corresponding symbol that is prefixed
with <code>cloudabi_sys_</code>. System calls should be invoked
through these entry points.</p>

<p>The first advantage of letting processes call into a
vDSO to perform system calls instead of raising
hardware traps is that it allows for easy emulation of
executables on top of existing operating systems. The
second advantage is that in cases where an operating
system provides native support for CloudABI executables,
it may still implement partial userspace
implementations of these system calls to improve
performance (e.g., <a href="#clock_time_get"><code>clock_time_get()</code></a>). It also provides
a more dynamic way of adding, removing or replacing
system calls.</p></li>
<li><p><a href="#auxtype.tid" name="auxtype.tid"></a><strong><code>TID</code></strong></p>

<p>Thread ID of the initial thread of the process.</p></li>
</ul>

<h4><a href="#auxv" name="auxv"></a><code>auxv</code> (<code>struct</code>)</h4>

<p>Auxiliary vector entry.</p>

<p>The auxiliary vector is a list of key-value pairs that is
provided to the process on startup. Unlike structures, it is
extensible, as it is possible to add new records later on.
The auxiliary vector is always terminated by an entry having
type <a href="#auxtype.null"><code>NULL</code></a>.</p>

<p>The auxiliary vector is part of the x86-64 ABI, but is used by
this environment on all architectures.</p>

<p>Used by <a href="#processentry"><code>processentry</code></a>.</p>

<p>Members:</p>

<ul>
<li><p><a href="#auxv.a_type" name="auxv.a_type"></a><code><strong>a_type</strong>: <a href="#auxtype">auxtype</a></code></p>

<p>The type of the auxiliary vector entry.</p></li>
<li><p>When <code>a_type</code> is <a href="#auxtype.argdatalen"><code>ARGDATALEN</code></a>, <a href="#auxtype.canarylen"><code>CANARYLEN</code></a>, <a href="#auxtype.ncpus"><code>NCPUS</code></a>, <a href="#auxtype.pagesz"><code>PAGESZ</code></a>, <a href="#auxtype.phnum"><code>PHNUM</code></a>, or <a href="#auxtype.tid"><code>TID</code></a>:</p>

<ul>
<li><p><a href="#auxv.a_val" name="auxv.a_val"></a><code><strong>union.a_val</strong>: usize</code></p>

<p>A numerical value.</p></li>
</ul></li>
<li><p>When <code>a_type</code> is <a href="#auxtype.argdata"><code>ARGDATA</code></a>, <a href="#auxtype.base"><code>BASE</code></a>, <a href="#auxtype.canary"><code>CANARY</code></a>, <a href="#auxtype.phdr"><code>PHDR</code></a>, <a href="#auxtype.pid"><code>PID</code></a>, or <a href="#auxtype.sysinfo_ehdr"><code>SYSINFO_EHDR</code></a>:</p>

<ul>
<li><p><a href="#auxv.a_ptr" name="auxv.a_ptr"></a><code><strong>union.a_ptr</strong>: *mut ()</code></p>

<p>A pointer value.</p></li>
</ul></li>
</ul>

<h4><a href="#ciovec" name="ciovec"></a><code>ciovec</code> (<code>struct</code>)</h4>

<p>A region of memory for scatter/gather writes.</p>

<p>Used by <a href="#send_in"><code>send_in</code></a>, <a href="#fd_pwrite"><code>fd_pwrite()</code></a>, and <a href="#fd_write"><code>fd_write()</code></a>.</p>

<p>Members:</p>

<ul>
<li><p><a href="#ciovec.buf" name="ciovec.buf"></a><code><strong>buf</strong>: *const ()</code> and <a href="#ciovec.buf_len" name="ciovec.buf_len"></a><code><strong>buf_len</strong>: usize</code></p>

<p>The address and length of the buffer to be written.</p></li>
</ul>

<h4><a href="#clockid" name="clockid"></a><code>clockid</code> (<code>u32</code> <code>enum</code>)</h4>

<p>Identifiers for clocks.</p>

<p>Used by <a href="#subscription"><code>subscription</code></a>, <a href="#clock_res_get"><code>clock_res_get()</code></a>, and <a href="#clock_time_get"><code>clock_time_get()</code></a>.</p>

<p>Possible values:</p>

<ul>
<li><p><a href="#clockid.monotonic" name="clockid.monotonic"></a><strong><code>MONOTONIC</code></strong></p>

<p>The system-wide monotonic clock, which is defined as a
clock measuring real time, whose value cannot be
adjusted and which cannot have negative clock jumps.</p>

<p>The epoch of this clock is undefined. The absolute
time value of this clock therefore has no meaning.</p></li>
<li><p><a href="#clockid.process_cputime_id" name="clockid.process_cputime_id"></a><strong><code>PROCESS_CPUTIME_ID</code></strong></p>

<p>The CPU-time clock associated with the current
process.</p></li>
<li><p><a href="#clockid.realtime" name="clockid.realtime"></a><strong><code>REALTIME</code></strong></p>

<p>The system-wide clock measuring real time. Time value
zero corresponds with 1970-01-01T00:00:00Z.</p></li>
<li><p><a href="#clockid.thread_cputime_id" name="clockid.thread_cputime_id"></a><strong><code>THREAD_CPUTIME_ID</code></strong></p>

<p>The CPU-time clock associated with the current thread.</p></li>
</ul>

<h4><a href="#condvar" name="condvar"></a><code>condvar</code> (<code>struct(u32)</code>)</h4>

<p>A userspace condition variable.</p>

<p>Used by <a href="#subscription"><code>subscription</code></a> and <a href="#condvar_signal"><code>condvar_signal()</code></a>.</p>

<p>Special values:</p>

<ul>
<li><p><a href="#condvar.has_no_waiters" name="condvar.has_no_waiters"></a><strong><code>CONDVAR_HAS_NO_WAITERS</code></strong></p>

<p>The condition variable is in its initial state. There
are no threads waiting to be woken up. If the
condition variable has any other value, the kernel
must be called to wake up any sleeping threads.</p></li>
</ul>

<h4><a href="#device" name="device"></a><code>device</code> (<code>struct(u64)</code>)</h4>

<p>Identifier for a device containing a file system. Can be used
in combination with <a href="#inode"><code>inode</code></a> to uniquely identify a file on the
local system.</p>

<p>Used by <a href="#filestat"><code>filestat</code></a>.</p>

<h4><a href="#dircookie" name="dircookie"></a><code>dircookie</code> (<code>struct(u64)</code>)</h4>

<p>A reference to the offset of a directory entry.</p>

<p>Used by <a href="#dirent"><code>dirent</code></a> and <a href="#file_readdir"><code>file_readdir()</code></a>.</p>

<p>Special values:</p>

<ul>
<li><p><a href="#dircookie.start" name="dircookie.start"></a><strong><code>DIRCOOKIE_START</code></strong></p>

<p>Permanent reference to the first directory entry
within a directory.</p></li>
</ul>

<h4><a href="#dirent" name="dirent"></a><code>dirent</code> (<code>struct</code>)</h4>

<p>A directory entry.</p>

<p>Members:</p>

<ul>
<li><p><a href="#dirent.d_next" name="dirent.d_next"></a><code><strong>d_next</strong>: <a href="#dircookie">dircookie</a></code></p>

<p>The offset of the next directory entry stored in this
directory.</p></li>
<li><p><a href="#dirent.d_ino" name="dirent.d_ino"></a><code><strong>d_ino</strong>: <a href="#inode">inode</a></code></p>

<p>The serial number of the file referred to by this
directory entry.</p></li>
<li><p><a href="#dirent.d_namlen" name="dirent.d_namlen"></a><code><strong>d_namlen</strong>: u32</code></p>

<p>The length of the name of the directory entry.</p></li>
<li><p><a href="#dirent.d_type" name="dirent.d_type"></a><code><strong>d_type</strong>: <a href="#filetype">filetype</a></code></p>

<p>The type of the file referred to by this directory
entry.</p></li>
</ul>

<h4><a href="#errno" name="errno"></a><code>errno</code> (<code>u16</code> <code>enum</code>)</h4>

<p>Error codes returned by system calls.</p>

<p>Not all of these error codes are returned by the system calls
provided by this environment, but are either used in userspace
exclusively or merely provided for alignment with POSIX.</p>

<p>Used by <a href="#event"><code>event</code></a>.</p>

<p>Possible values:</p>

<ul>
<li><p><a href="#errno.success" name="errno.success"></a><strong><code>SUCCESS</code></strong></p>

<p>No error occurred. System call completed successfully.</p></li>
<li><p><a href="#errno.2big" name="errno.2big"></a><strong><code>TOOBIG</code></strong></p>

<p>Argument list too long.</p></li>
<li><p><a href="#errno.acces" name="errno.acces"></a><strong><code>ACCES</code></strong></p>

<p>Permission denied.</p></li>
<li><p><a href="#errno.addrinuse" name="errno.addrinuse"></a><strong><code>ADDRINUSE</code></strong></p>

<p>Address in use.</p></li>
<li><p><a href="#errno.addrnotavail" name="errno.addrnotavail"></a><strong><code>ADDRNOTAVAIL</code></strong></p>

<p>Address not available.</p></li>
<li><p><a href="#errno.afnosupport" name="errno.afnosupport"></a><strong><code>AFNOSUPPORT</code></strong></p>

<p>Address family not supported.</p></li>
<li><p><a href="#errno.again" name="errno.again"></a><strong><code>AGAIN</code></strong></p>

<p>Resource unavailable, or operation would block.</p></li>
<li><p><a href="#errno.already" name="errno.already"></a><strong><code>ALREADY</code></strong></p>

<p>Connection already in progress.</p></li>
<li><p><a href="#errno.badf" name="errno.badf"></a><strong><code>BADF</code></strong></p>

<p>Bad file descriptor.</p></li>
<li><p><a href="#errno.badmsg" name="errno.badmsg"></a><strong><code>BADMSG</code></strong></p>

<p>Bad message.</p></li>
<li><p><a href="#errno.busy" name="errno.busy"></a><strong><code>BUSY</code></strong></p>

<p>Device or resource busy.</p></li>
<li><p><a href="#errno.canceled" name="errno.canceled"></a><strong><code>CANCELED</code></strong></p>

<p>Operation canceled.</p></li>
<li><p><a href="#errno.child" name="errno.child"></a><strong><code>CHILD</code></strong></p>

<p>No child processes.</p></li>
<li><p><a href="#errno.connaborted" name="errno.connaborted"></a><strong><code>CONNABORTED</code></strong></p>

<p>Connection aborted.</p></li>
<li><p><a href="#errno.connrefused" name="errno.connrefused"></a><strong><code>CONNREFUSED</code></strong></p>

<p>Connection refused.</p></li>
<li><p><a href="#errno.connreset" name="errno.connreset"></a><strong><code>CONNRESET</code></strong></p>

<p>Connection reset.</p></li>
<li><p><a href="#errno.deadlk" name="errno.deadlk"></a><strong><code>DEADLK</code></strong></p>

<p>Resource deadlock would occur.</p></li>
<li><p><a href="#errno.destaddrreq" name="errno.destaddrreq"></a><strong><code>DESTADDRREQ</code></strong></p>

<p>Destination address required.</p></li>
<li><p><a href="#errno.dom" name="errno.dom"></a><strong><code>DOM</code></strong></p>

<p>Mathematics argument out of domain of function.</p></li>
<li><p><a href="#errno.dquot" name="errno.dquot"></a><strong><code>DQUOT</code></strong></p>

<p>Reserved.</p></li>
<li><p><a href="#errno.exist" name="errno.exist"></a><strong><code>EXIST</code></strong></p>

<p>File exists.</p></li>
<li><p><a href="#errno.fault" name="errno.fault"></a><strong><code>FAULT</code></strong></p>

<p>Bad address.</p></li>
<li><p><a href="#errno.fbig" name="errno.fbig"></a><strong><code>FBIG</code></strong></p>

<p>File too large.</p></li>
<li><p><a href="#errno.hostunreach" name="errno.hostunreach"></a><strong><code>HOSTUNREACH</code></strong></p>

<p>Host is unreachable.</p></li>
<li><p><a href="#errno.idrm" name="errno.idrm"></a><strong><code>IDRM</code></strong></p>

<p>Identifier removed.</p></li>
<li><p><a href="#errno.ilseq" name="errno.ilseq"></a><strong><code>ILSEQ</code></strong></p>

<p>Illegal byte sequence.</p></li>
<li><p><a href="#errno.inprogress" name="errno.inprogress"></a><strong><code>INPROGRESS</code></strong></p>

<p>Operation in progress.</p></li>
<li><p><a href="#errno.intr" name="errno.intr"></a><strong><code>INTR</code></strong></p>

<p>Interrupted function.</p></li>
<li><p><a href="#errno.inval" name="errno.inval"></a><strong><code>INVAL</code></strong></p>

<p>Invalid argument.</p></li>
<li><p><a href="#errno.io" name="errno.io"></a><strong><code>IO</code></strong></p>

<p>I/O error.</p></li>
<li><p><a href="#errno.isconn" name="errno.isconn"></a><strong><code>ISCONN</code></strong></p>

<p>Socket is connected.</p></li>
<li><p><a href="#errno.isdir" name="errno.isdir"></a><strong><code>ISDIR</code></strong></p>

<p>Is a directory.</p></li>
<li><p><a href="#errno.loop" name="errno.loop"></a><strong><code>LOOP</code></strong></p>

<p>Too many levels of symbolic links.</p></li>
<li><p><a href="#errno.mfile" name="errno.mfile"></a><strong><code>MFILE</code></strong></p>

<p>File descriptor value too large.</p></li>
<li><p><a href="#errno.mlink" name="errno.mlink"></a><strong><code>MLINK</code></strong></p>

<p>Too many links.</p></li>
<li><p><a href="#errno.msgsize" name="errno.msgsize"></a><strong><code>MSGSIZE</code></strong></p>

<p>Message too large.</p></li>
<li><p><a href="#errno.multihop" name="errno.multihop"></a><strong><code>MULTIHOP</code></strong></p>

<p>Reserved.</p></li>
<li><p><a href="#errno.nametoolong" name="errno.nametoolong"></a><strong><code>NAMETOOLONG</code></strong></p>

<p>Filename too long.</p></li>
<li><p><a href="#errno.netdown" name="errno.netdown"></a><strong><code>NETDOWN</code></strong></p>

<p>Network is down.</p></li>
<li><p><a href="#errno.netreset" name="errno.netreset"></a><strong><code>NETRESET</code></strong></p>

<p>Connection aborted by network.</p></li>
<li><p><a href="#errno.netunreach" name="errno.netunreach"></a><strong><code>NETUNREACH</code></strong></p>

<p>Network unreachable.</p></li>
<li><p><a href="#errno.nfile" name="errno.nfile"></a><strong><code>NFILE</code></strong></p>

<p>Too many files open in system.</p></li>
<li><p><a href="#errno.nobufs" name="errno.nobufs"></a><strong><code>NOBUFS</code></strong></p>

<p>No buffer space available.</p></li>
<li><p><a href="#errno.nodev" name="errno.nodev"></a><strong><code>NODEV</code></strong></p>

<p>No such device.</p></li>
<li><p><a href="#errno.noent" name="errno.noent"></a><strong><code>NOENT</code></strong></p>

<p>No such file or directory.</p></li>
<li><p><a href="#errno.noexec" name="errno.noexec"></a><strong><code>NOEXEC</code></strong></p>

<p>Executable file format error.</p></li>
<li><p><a href="#errno.nolck" name="errno.nolck"></a><strong><code>NOLCK</code></strong></p>

<p>No locks available.</p></li>
<li><p><a href="#errno.nolink" name="errno.nolink"></a><strong><code>NOLINK</code></strong></p>

<p>Reserved.</p></li>
<li><p><a href="#errno.nomem" name="errno.nomem"></a><strong><code>NOMEM</code></strong></p>

<p>Not enough space.</p></li>
<li><p><a href="#errno.nomsg" name="errno.nomsg"></a><strong><code>NOMSG</code></strong></p>

<p>No message of the desired type.</p></li>
<li><p><a href="#errno.noprotoopt" name="errno.noprotoopt"></a><strong><code>NOPROTOOPT</code></strong></p>

<p>Protocol not available.</p></li>
<li><p><a href="#errno.nospc" name="errno.nospc"></a><strong><code>NOSPC</code></strong></p>

<p>No space left on device.</p></li>
<li><p><a href="#errno.nosys" name="errno.nosys"></a><strong><code>NOSYS</code></strong></p>

<p>Function not supported.</p></li>
<li><p><a href="#errno.notconn" name="errno.notconn"></a><strong><code>NOTCONN</code></strong></p>

<p>The socket is not connected.</p></li>
<li><p><a href="#errno.notdir" name="errno.notdir"></a><strong><code>NOTDIR</code></strong></p>

<p>Not a directory or a symbolic link to a directory.</p></li>
<li><p><a href="#errno.notempty" name="errno.notempty"></a><strong><code>NOTEMPTY</code></strong></p>

<p>Directory not empty.</p></li>
<li><p><a href="#errno.notrecoverable" name="errno.notrecoverable"></a><strong><code>NOTRECOVERABLE</code></strong></p>

<p>State not recoverable.</p></li>
<li><p><a href="#errno.notsock" name="errno.notsock"></a><strong><code>NOTSOCK</code></strong></p>

<p>Not a socket.</p></li>
<li><p><a href="#errno.notsup" name="errno.notsup"></a><strong><code>NOTSUP</code></strong></p>

<p>Not supported, or operation not supported on socket.</p></li>
<li><p><a href="#errno.notty" name="errno.notty"></a><strong><code>NOTTY</code></strong></p>

<p>Inappropriate I/O control operation.</p></li>
<li><p><a href="#errno.nxio" name="errno.nxio"></a><strong><code>NXIO</code></strong></p>

<p>No such device or address.</p></li>
<li><p><a href="#errno.overflow" name="errno.overflow"></a><strong><code>OVERFLOW</code></strong></p>

<p>Value too large to be stored in data type.</p></li>
<li><p><a href="#errno.ownerdead" name="errno.ownerdead"></a><strong><code>OWNERDEAD</code></strong></p>

<p>Previous owner died.</p></li>
<li><p><a href="#errno.perm" name="errno.perm"></a><strong><code>PERM</code></strong></p>

<p>Operation not permitted.</p></li>
<li><p><a href="#errno.pipe" name="errno.pipe"></a><strong><code>PIPE</code></strong></p>

<p>Broken pipe.</p></li>
<li><p><a href="#errno.proto" name="errno.proto"></a><strong><code>PROTO</code></strong></p>

<p>Protocol error.</p></li>
<li><p><a href="#errno.protonosupport" name="errno.protonosupport"></a><strong><code>PROTONOSUPPORT</code></strong></p>

<p>Protocol not supported.</p></li>
<li><p><a href="#errno.prototype" name="errno.prototype"></a><strong><code>PROTOTYPE</code></strong></p>

<p>Protocol wrong type for socket.</p></li>
<li><p><a href="#errno.range" name="errno.range"></a><strong><code>RANGE</code></strong></p>

<p>Result too large.</p></li>
<li><p><a href="#errno.rofs" name="errno.rofs"></a><strong><code>ROFS</code></strong></p>

<p>Read-only file system.</p></li>
<li><p><a href="#errno.spipe" name="errno.spipe"></a><strong><code>SPIPE</code></strong></p>

<p>Invalid seek.</p></li>
<li><p><a href="#errno.srch" name="errno.srch"></a><strong><code>SRCH</code></strong></p>

<p>No such process.</p></li>
<li><p><a href="#errno.stale" name="errno.stale"></a><strong><code>STALE</code></strong></p>

<p>Reserved.</p></li>
<li><p><a href="#errno.timedout" name="errno.timedout"></a><strong><code>TIMEDOUT</code></strong></p>

<p>Connection timed out.</p></li>
<li><p><a href="#errno.txtbsy" name="errno.txtbsy"></a><strong><code>TXTBSY</code></strong></p>

<p>Text file busy.</p></li>
<li><p><a href="#errno.xdev" name="errno.xdev"></a><strong><code>XDEV</code></strong></p>

<p>Cross-device link.</p></li>
<li><p><a href="#errno.notcapable" name="errno.notcapable"></a><strong><code>NOTCAPABLE</code></strong></p>

<p>Extension: Capabilities insufficient.</p></li>
</ul>

<h4><a href="#event" name="event"></a><code>event</code> (<code>struct</code>)</h4>

<p>An event that occurred.</p>

<p>Used by <a href="#poll"><code>poll()</code></a>.</p>

<p>Members:</p>

<ul>
<li><p><a href="#event.userdata" name="event.userdata"></a><code><strong>userdata</strong>: <a href="#userdata">userdata</a></code></p>

<p>User-provided value that got attached to
<a href="#subscription.userdata"><code>subscription.userdata</code></a>.</p></li>
<li><p><a href="#event.error" name="event.error"></a><code><strong>error</strong>: <a href="#errno">errno</a></code></p>

<p>If non-zero, an error that occurred while processing
the subscription request.</p></li>
<li><p><a href="#event.type" name="event.type"></a><code><strong>r#type</strong>: <a href="#eventtype">eventtype</a></code></p>

<p>The type of the event that occurred.</p></li>
<li><p>When <code>type</code> is <a href="#eventtype.fd_read"><code>FD_READ</code></a> or <a href="#eventtype.fd_write"><code>FD_WRITE</code></a>:</p>

<ul>
<li><p><a href="#event.fd_readwrite" name="event.fd_readwrite"></a><strong><code>union.fd_readwrite</code></strong></p>

<ul>
<li><p><a href="#event.fd_readwrite.nbytes" name="event.fd_readwrite.nbytes"></a><code><strong>nbytes</strong>: <a href="#filesize">filesize</a></code></p>

<p>The number of bytes available
for reading or writing.</p></li>
<li><p><a href="#event.fd_readwrite.unused" name="event.fd_readwrite.unused"></a><code><strong>unused</strong>: [u8; 4]</code></p>

<p>Obsolete.</p></li>
<li><p><a href="#event.fd_readwrite.flags" name="event.fd_readwrite.flags"></a><code><strong>flags</strong>: <a href="#eventrwflags">eventrwflags</a></code></p>

<p>The state of the file
descriptor.</p></li>
</ul></li>
</ul></li>
<li><p>When <code>type</code> is <a href="#eventtype.proc_terminate"><code>PROC_TERMINATE</code></a>:</p>

<ul>
<li><p><a href="#event.proc_terminate" name="event.proc_terminate"></a><strong><code>union.proc_terminate</code></strong></p>

<ul>
<li><p><a href="#event.proc_terminate.unused" name="event.proc_terminate.unused"></a><code><strong>unused</strong>: [u8; 4]</code></p>

<p>Obsolete.</p></li>
<li><p><a href="#event.proc_terminate.signal" name="event.proc_terminate.signal"></a><code><strong>signal</strong>: <a href="#signal">signal</a></code></p>

<p>If zero, the process has
exited.
Otherwise, the signal
condition causing it to
terminated.</p></li>
<li><p><a href="#event.proc_terminate.exitcode" name="event.proc_terminate.exitcode"></a><code><strong>exitcode</strong>: <a href="#exitcode">exitcode</a></code></p>

<p>If exited, the exit code of
the process.</p></li>
</ul></li>
</ul></li>
</ul>

<h4><a href="#eventrwflags" name="eventrwflags"></a><code>eventrwflags</code> (<code>u16</code> bitfield)</h4>

<p>The state of the file descriptor subscribed to with
<a href="#eventtype.fd_read"><code>FD_READ</code></a> or <a href="#eventtype.fd_write"><code>FD_WRITE</code></a>.</p>

<p>Used by <a href="#event"><code>event</code></a>.</p>

<p>Possible values:</p>

<ul>
<li><p><a href="#eventrwflags.hangup" name="eventrwflags.hangup"></a><strong><code>HANGUP</code></strong></p>

<p>The peer of this socket has closed or disconnected.</p></li>
</ul>

<h4><a href="#eventtype" name="eventtype"></a><code>eventtype</code> (<code>u8</code> <code>enum</code>)</h4>

<p>Type of a subscription to an event or its occurrence.</p>

<p>Used by <a href="#event"><code>event</code></a> and <a href="#subscription"><code>subscription</code></a>.</p>

<p>Possible values:</p>

<ul>
<li><p><a href="#eventtype.clock" name="eventtype.clock"></a><strong><code>CLOCK</code></strong></p>

<p>The time value of clock <a href="#subscription.clock.clock_id"><code>subscription.union.clock.clock_id</code></a>
has reached timestamp <a href="#subscription.clock.timeout"><code>subscription.union.clock.timeout</code></a>.</p></li>
<li><p><a href="#eventtype.condvar" name="eventtype.condvar"></a><strong><code>CONDVAR</code></strong></p>

<p>Condition variable <a href="#subscription.condvar.condvar"><code>subscription.union.condvar.condvar</code></a> has
been woken up and <a href="#subscription.condvar.lock"><code>subscription.union.condvar.lock</code></a> has been
acquired for writing.</p></li>
<li><p><a href="#eventtype.fd_read" name="eventtype.fd_read"></a><strong><code>FD_READ</code></strong></p>

<p>File descriptor <a href="#subscription.fd_readwrite.fd"><code>subscription.union.fd_readwrite.fd</code></a> has
data available for reading. This event always triggers
for regular files.</p></li>
<li><p><a href="#eventtype.fd_write" name="eventtype.fd_write"></a><strong><code>FD_WRITE</code></strong></p>

<p>File descriptor <a href="#subscription.fd_readwrite.fd"><code>subscription.union.fd_readwrite.fd</code></a> has
capacity available for writing. This event always
triggers for regular files.</p></li>
<li><p><a href="#eventtype.lock_rdlock" name="eventtype.lock_rdlock"></a><strong><code>LOCK_RDLOCK</code></strong></p>

<p>Lock <a href="#subscription.lock.lock"><code>subscription.union.lock.lock</code></a> has been acquired for
reading.</p></li>
<li><p><a href="#eventtype.lock_wrlock" name="eventtype.lock_wrlock"></a><strong><code>LOCK_WRLOCK</code></strong></p>

<p>Lock <a href="#subscription.lock.lock"><code>subscription.union.lock.lock</code></a> has been acquired for
writing.</p></li>
<li><p><a href="#eventtype.proc_terminate" name="eventtype.proc_terminate"></a><strong><code>PROC_TERMINATE</code></strong></p>

<p>The process associated with process descriptor
<a href="#subscription.proc_terminate.fd"><code>subscription.union.proc_terminate.fd</code></a> has terminated.</p></li>
</ul>

<h4><a href="#exitcode" name="exitcode"></a><code>exitcode</code> (= <code>u32</code>)</h4>

<p>Exit code generated by a process when exiting.</p>

<p>Used by <a href="#event"><code>event</code></a> and <a href="#proc_exit"><code>proc_exit()</code></a>.</p>

<h4><a href="#fd" name="fd"></a><code>fd</code> (<code>struct(u32)</code>)</h4>

<p>A file descriptor number.</p>

<p>Unlike on POSIX-compliant systems, none of the file descriptor
numbers are reserved for a purpose (e.g., stdin, stdout,
stderr). Operating systems are not required to allocate new
file descriptors in ascending order.</p>

<p>Special values:</p>

<ul>
<li><p><a href="#fd.process_child" name="fd.process_child"></a><strong><code>PROCESS_CHILD</code></strong></p>

<p>Returned to the child process by <a href="#proc_fork"><code>proc_fork()</code></a>.</p></li>
<li><p><a href="#fd.map_anon_fd" name="fd.map_anon_fd"></a><strong><code>MAP_ANON_FD</code></strong></p>

<p>Passed to <a href="#mem_map"><code>mem_map()</code></a> when creating a mapping to
anonymous memory.</p></li>
</ul>

<h4><a href="#fdflags" name="fdflags"></a><code>fdflags</code> (<code>u16</code> bitfield)</h4>

<p>File descriptor flags.</p>

<p>Used by <a href="#fdstat"><code>fdstat</code></a>.</p>

<p>Possible values:</p>

<ul>
<li><p><a href="#fdflags.append" name="fdflags.append"></a><strong><code>APPEND</code></strong></p>

<p>Append mode: Data written to the file is always
appended to the file's end.</p></li>
<li><p><a href="#fdflags.dsync" name="fdflags.dsync"></a><strong><code>DSYNC</code></strong></p>

<p>Write according to synchronized I/O data integrity
completion. Only the data stored in the file is
synchronized.</p></li>
<li><p><a href="#fdflags.nonblock" name="fdflags.nonblock"></a><strong><code>NONBLOCK</code></strong></p>

<p>Non-blocking mode.</p></li>
<li><p><a href="#fdflags.rsync" name="fdflags.rsync"></a><strong><code>RSYNC</code></strong></p>

<p>Synchronized read I/O operations.</p></li>
<li><p><a href="#fdflags.sync" name="fdflags.sync"></a><strong><code>SYNC</code></strong></p>

<p>Write according to synchronized I/O file integrity
completion. In addition to synchronizing the data
stored in the file, the system may also synchronously
update the file's metadata.</p></li>
</ul>

<h4><a href="#fdsflags" name="fdsflags"></a><code>fdsflags</code> (<code>u16</code> bitfield)</h4>

<p>Which file descriptor attributes to adjust.</p>

<p>Used by <a href="#fd_stat_put"><code>fd_stat_put()</code></a>.</p>

<p>Possible values:</p>

<ul>
<li><p><a href="#fdsflags.flags" name="fdsflags.flags"></a><strong><code>FLAGS</code></strong></p>

<p>Adjust the file descriptor flags stored in
<a href="#fdstat.fs_flags"><code>fdstat.fs_flags</code></a>.</p></li>
<li><p><a href="#fdsflags.rights" name="fdsflags.rights"></a><strong><code>RIGHTS</code></strong></p>

<p>Restrict the rights of the file descriptor to the
rights stored in <a href="#fdstat.fs_rights_base"><code>fdstat.fs_rights_base</code></a> and
<a href="#fdstat.fs_rights_inheriting"><code>fdstat.fs_rights_inheriting</code></a>.</p></li>
</ul>

<h4><a href="#fdstat" name="fdstat"></a><code>fdstat</code> (<code>struct</code>)</h4>

<p>File descriptor attributes.</p>

<p>Used by <a href="#fd_stat_get"><code>fd_stat_get()</code></a>, <a href="#fd_stat_put"><code>fd_stat_put()</code></a>, and <a href="#file_open"><code>file_open()</code></a>.</p>

<p>Members:</p>

<ul>
<li><p><a href="#fdstat.fs_filetype" name="fdstat.fs_filetype"></a><code><strong>fs_filetype</strong>: <a href="#filetype">filetype</a></code></p>

<p>File type.</p></li>
<li><p><a href="#fdstat.fs_flags" name="fdstat.fs_flags"></a><code><strong>fs_flags</strong>: <a href="#fdflags">fdflags</a></code></p>

<p>File descriptor flags.</p></li>
<li><p><a href="#fdstat.fs_rights_base" name="fdstat.fs_rights_base"></a><code><strong>fs_rights_base</strong>: <a href="#rights">rights</a></code></p>

<p>Rights that apply to this file descriptor.</p></li>
<li><p><a href="#fdstat.fs_rights_inheriting" name="fdstat.fs_rights_inheriting"></a><code><strong>fs_rights_inheriting</strong>: <a href="#rights">rights</a></code></p>

<p>Maximum set of rights that can be installed on new
file descriptors that are created through this file
descriptor, e.g., through <a href="#file_open"><code>file_open()</code></a>.</p></li>
</ul>

<h4><a href="#filedelta" name="filedelta"></a><code>filedelta</code> (= <code>i64</code>)</h4>

<p>Relative offset within a file.</p>

<p>Used by <a href="#fd_seek"><code>fd_seek()</code></a>.</p>

<h4><a href="#filesize" name="filesize"></a><code>filesize</code> (= <code>u64</code>)</h4>

<p>Non-negative file size or length of a region within a file.</p>

<p>Used by <a href="#event"><code>event</code></a>, <a href="#filestat"><code>filestat</code></a>, <a href="#fd_pread"><code>fd_pread()</code></a>, <a href="#fd_pwrite"><code>fd_pwrite()</code></a>, <a href="#fd_seek"><code>fd_seek()</code></a>, <a href="#file_advise"><code>file_advise()</code></a>, <a href="#file_allocate"><code>file_allocate()</code></a>, and <a href="#mem_map"><code>mem_map()</code></a>.</p>

<h4><a href="#filestat" name="filestat"></a><code>filestat</code> (<code>struct</code>)</h4>

<p>File attributes.</p>

<p>Used by <a href="#file_stat_fget"><code>file_stat_fget()</code></a>, <a href="#file_stat_fput"><code>file_stat_fput()</code></a>, <a href="#file_stat_get"><code>file_stat_get()</code></a>, and <a href="#file_stat_put"><code>file_stat_put()</code></a>.</p>

<p>Members:</p>

<ul>
<li><p><a href="#filestat.st_dev" name="filestat.st_dev"></a><code><strong>st_dev</strong>: <a href="#device">device</a></code></p>

<p>Device ID of device containing the file.</p></li>
<li><p><a href="#filestat.st_ino" name="filestat.st_ino"></a><code><strong>st_ino</strong>: <a href="#inode">inode</a></code></p>

<p>File serial number.</p></li>
<li><p><a href="#filestat.st_filetype" name="filestat.st_filetype"></a><code><strong>st_filetype</strong>: <a href="#filetype">filetype</a></code></p>

<p>File type.</p></li>
<li><p><a href="#filestat.st_nlink" name="filestat.st_nlink"></a><code><strong>st_nlink</strong>: <a href="#linkcount">linkcount</a></code></p>

<p>Number of hard links to the file.</p></li>
<li><p><a href="#filestat.st_size" name="filestat.st_size"></a><code><strong>st_size</strong>: <a href="#filesize">filesize</a></code></p>

<p>For regular files, the file size in bytes. For
symbolic links, the length in bytes of the pathname
contained in the symbolic link.</p></li>
<li><p><a href="#filestat.st_atim" name="filestat.st_atim"></a><code><strong>st_atim</strong>: <a href="#timestamp">timestamp</a></code></p>

<p>Last data access timestamp.</p></li>
<li><p><a href="#filestat.st_mtim" name="filestat.st_mtim"></a><code><strong>st_mtim</strong>: <a href="#timestamp">timestamp</a></code></p>

<p>Last data modification timestamp.</p></li>
<li><p><a href="#filestat.st_ctim" name="filestat.st_ctim"></a><code><strong>st_ctim</strong>: <a href="#timestamp">timestamp</a></code></p>

<p>Last file status change timestamp.</p></li>
</ul>

<h4><a href="#filetype" name="filetype"></a><code>filetype</code> (<code>u8</code> <code>enum</code>)</h4>

<p>The type of a file descriptor or file.</p>

<p>Used by <a href="#dirent"><code>dirent</code></a>, <a href="#fdstat"><code>fdstat</code></a>, <a href="#filestat"><code>filestat</code></a>, <a href="#fd_create1"><code>fd_create1()</code></a>, <a href="#fd_create2"><code>fd_create2()</code></a>, and <a href="#file_create"><code>file_create()</code></a>.</p>

<p>Possible values:</p>

<ul>
<li><p><a href="#filetype.unknown" name="filetype.unknown"></a><strong><code>UNKNOWN</code></strong></p>

<p>The type of the file descriptor or file is unknown or
is different from any of the other types specified.</p></li>
<li><p><a href="#filetype.block_device" name="filetype.block_device"></a><strong><code>BLOCK_DEVICE</code></strong></p>

<p>The file descriptor or file refers to a block device
inode.</p></li>
<li><p><a href="#filetype.character_device" name="filetype.character_device"></a><strong><code>CHARACTER_DEVICE</code></strong></p>

<p>The file descriptor or file refers to a character
device inode.</p></li>
<li><p><a href="#filetype.directory" name="filetype.directory"></a><strong><code>DIRECTORY</code></strong></p>

<p>The file descriptor or file refers to a directory
inode.</p></li>
<li><p><a href="#filetype.process" name="filetype.process"></a><strong><code>PROCESS</code></strong></p>

<p>The file descriptor refers to a process handle.</p></li>
<li><p><a href="#filetype.regular_file" name="filetype.regular_file"></a><strong><code>REGULAR_FILE</code></strong></p>

<p>The file descriptor or file refers to a regular file
inode.</p></li>
<li><p><a href="#filetype.shared_memory" name="filetype.shared_memory"></a><strong><code>SHARED_MEMORY</code></strong></p>

<p>The file descriptor refers to a shared memory object.</p></li>
<li><p><a href="#filetype.socket_dgram" name="filetype.socket_dgram"></a><strong><code>SOCKET_DGRAM</code></strong></p>

<p>The file descriptor or file refers to a datagram
socket.</p></li>
<li><p><a href="#filetype.socket_stream" name="filetype.socket_stream"></a><strong><code>SOCKET_STREAM</code></strong></p>

<p>The file descriptor or file refers to a byte-stream
socket.</p></li>
<li><p><a href="#filetype.symbolic_link" name="filetype.symbolic_link"></a><strong><code>SYMBOLIC_LINK</code></strong></p>

<p>The file refers to a symbolic link inode.</p></li>
</ul>

<h4><a href="#fsflags" name="fsflags"></a><code>fsflags</code> (<code>u16</code> bitfield)</h4>

<p>Which file attributes to adjust.</p>

<p>Used by <a href="#file_stat_fput"><code>file_stat_fput()</code></a> and <a href="#file_stat_put"><code>file_stat_put()</code></a>.</p>

<p>Possible values:</p>

<ul>
<li><p><a href="#fsflags.atim" name="fsflags.atim"></a><strong><code>ATIM</code></strong></p>

<p>Adjust the last data access timestamp to the value
stored in <a href="#filestat.st_atim"><code>filestat.st_atim</code></a>.</p></li>
<li><p><a href="#fsflags.atim_now" name="fsflags.atim_now"></a><strong><code>ATIM_NOW</code></strong></p>

<p>Adjust the last data access timestamp to the time
of clock <a href="#clockid.realtime"><code>REALTIME</code></a>.</p></li>
<li><p><a href="#fsflags.mtim" name="fsflags.mtim"></a><strong><code>MTIM</code></strong></p>

<p>Adjust the last data modification timestamp to the
value stored in <a href="#filestat.st_mtim"><code>filestat.st_mtim</code></a>.</p></li>
<li><p><a href="#fsflags.mtim_now" name="fsflags.mtim_now"></a><strong><code>MTIM_NOW</code></strong></p>

<p>Adjust the last data modification timestamp to the
time of clock <a href="#clockid.realtime"><code>REALTIME</code></a>.</p></li>
<li><p><a href="#fsflags.size" name="fsflags.size"></a><strong><code>SIZE</code></strong></p>

<p>Truncate or extend the file to the size stored in
<a href="#filestat.st_size"><code>filestat.st_size</code></a>.</p></li>
</ul>

<h4><a href="#inode" name="inode"></a><code>inode</code> (<code>struct(u64)</code>)</h4>

<p>File serial number that is unique within its file system.</p>

<p>Used by <a href="#dirent"><code>dirent</code></a> and <a href="#filestat"><code>filestat</code></a>.</p>

<h4><a href="#iovec" name="iovec"></a><code>iovec</code> (<code>struct</code>)</h4>

<p>A region of memory for scatter/gather reads.</p>

<p>Used by <a href="#recv_in"><code>recv_in</code></a>, <a href="#fd_pread"><code>fd_pread()</code></a>, and <a href="#fd_read"><code>fd_read()</code></a>.</p>

<p>Members:</p>

<ul>
<li><p><a href="#iovec.buf" name="iovec.buf"></a><code><strong>buf</strong>: *mut ()</code> and <a href="#iovec.buf_len" name="iovec.buf_len"></a><code><strong>buf_len</strong>: usize</code></p>

<p>The address and length of the buffer to be filled.</p></li>
</ul>

<h4><a href="#linkcount" name="linkcount"></a><code>linkcount</code> (= <code>u32</code>)</h4>

<p>Number of hard links to an inode.</p>

<p>Used by <a href="#filestat"><code>filestat</code></a>.</p>

<h4><a href="#lock" name="lock"></a><code>lock</code> (<code>struct(u32)</code>)</h4>

<p>A userspace read-recursive readers-writer lock, similar to a
Linux futex or a FreeBSD umtx.</p>

<p>Used by <a href="#subscription"><code>subscription</code></a>, <a href="#lock_unlock"><code>lock_unlock()</code></a>, and <a href="#thread_exit"><code>thread_exit()</code></a>.</p>

<p>Special values:</p>

<ul>
<li><p><a href="#lock.unlocked" name="lock.unlocked"></a><strong><code>LOCK_UNLOCKED</code></strong></p>

<p>Value indicating that the lock is in its initial
unlocked state.</p></li>
<li><p><a href="#lock.wrlocked" name="lock.wrlocked"></a><strong><code>LOCK_WRLOCKED</code></strong></p>

<p>Bitmask indicating that the lock is write-locked. If
set, the lower 30 bits of the lock contain the
identifier of the thread that owns the write lock.
Otherwise, the lower 30 bits of the lock contain the
number of acquired read locks.</p></li>
<li><p><a href="#lock.kernel_managed" name="lock.kernel_managed"></a><strong><code>LOCK_KERNEL_MANAGED</code></strong></p>

<p>Bitmask indicating that the lock is either read locked
or write locked, and that one or more threads have
their execution suspended, waiting to acquire the
lock. The last owner of the lock must call the
kernel to unlock.</p>

<p>When the lock is acquired for reading and this bit is
set, it means that one or more threads are attempting
to acquire this lock for writing. In that case, other
threads should only acquire additional read locks if
suspending execution would cause a deadlock. It is
preferred to suspend execution, as this prevents
starvation of writers.</p></li>
<li><p><a href="#lock.bogus" name="lock.bogus"></a><strong><code>LOCK_BOGUS</code></strong></p>

<p>Value indicating that the lock is in an incorrect
state. A lock cannot be in its initial unlocked state,
while also managed by the kernel.</p></li>
</ul>

<h4><a href="#lookup" name="lookup"></a><code>lookup</code> (<code>struct</code>)</h4>

<p>Path lookup properties.</p>

<p>Used by <a href="#file_link"><code>file_link()</code></a>, <a href="#file_open"><code>file_open()</code></a>, <a href="#file_stat_get"><code>file_stat_get()</code></a>, and <a href="#file_stat_put"><code>file_stat_put()</code></a>.</p>

<p>Members:</p>

<ul>
<li><p><a href="#lookup.fd" name="lookup.fd"></a><code><strong>fd</strong>: <a href="#fd">fd</a></code></p>

<p>The working directory at which the resolution of the
path starts.</p></li>
<li><p><a href="#lookup.flags" name="lookup.flags"></a><code><strong>flags</strong>: <a href="#lookupflags">lookupflags</a></code></p>

<p>Flags determining the method of how the path is
resolved.</p></li>
</ul>

<h4><a href="#lookupflags" name="lookupflags"></a><code>lookupflags</code> (<code>u32</code> bitfield)</h4>

<p>Flags determining the method of how paths are resolved.</p>

<p>Used by <a href="#lookup"><code>lookup</code></a>.</p>

<p>Possible values:</p>

<ul>
<li><p><a href="#lookupflags.symlink_follow" name="lookupflags.symlink_follow"></a><strong><code>SYMLINK_FOLLOW</code></strong></p>

<p>As long as the resolved path corresponds to a symbolic
link, it is expanded.</p></li>
</ul>

<h4><a href="#mflags" name="mflags"></a><code>mflags</code> (<code>u8</code> bitfield)</h4>

<p>Memory mapping flags.</p>

<p>Used by <a href="#mem_map"><code>mem_map()</code></a>.</p>

<p>Possible values:</p>

<ul>
<li><p><a href="#mflags.anon" name="mflags.anon"></a><strong><code>ANON</code></strong></p>

<p>Instead of mapping the contents of the file provided,
create a mapping to anonymous memory. The file
descriptor argument must be set to <a href="#fd.map_anon_fd"><code>MAP_ANON_FD</code></a>,
and the offset must be set to zero.</p></li>
<li><p><a href="#mflags.fixed" name="mflags.fixed"></a><strong><code>FIXED</code></strong></p>

<p>Require that the mapping is performed at the base
address provided.</p></li>
<li><p><a href="#mflags.private" name="mflags.private"></a><strong><code>PRIVATE</code></strong></p>

<p>Changes are private.</p></li>
<li><p><a href="#mflags.shared" name="mflags.shared"></a><strong><code>SHARED</code></strong></p>

<p>Changes are shared.</p></li>
</ul>

<h4><a href="#mprot" name="mprot"></a><code>mprot</code> (<code>u8</code> bitfield)</h4>

<p>Memory page protection options.</p>

<p>This implementation enforces the <code>W^X</code> property: Pages cannot be
mapped for execution while also mapped for writing.</p>

<p>Used by <a href="#mem_map"><code>mem_map()</code></a> and <a href="#mem_protect"><code>mem_protect()</code></a>.</p>

<p>Possible values:</p>

<ul>
<li><p><a href="#mprot.exec" name="mprot.exec"></a><strong><code>EXEC</code></strong></p>

<p>Page can be executed.</p></li>
<li><p><a href="#mprot.write" name="mprot.write"></a><strong><code>WRITE</code></strong></p>

<p>Page can be written.</p></li>
<li><p><a href="#mprot.read" name="mprot.read"></a><strong><code>READ</code></strong></p>

<p>Page can be read.</p></li>
</ul>

<h4><a href="#msflags" name="msflags"></a><code>msflags</code> (<code>u8</code> bitfield)</h4>

<p>Methods of synchronizing memory with physical storage.</p>

<p>Used by <a href="#mem_sync"><code>mem_sync()</code></a>.</p>

<p>Possible values:</p>

<ul>
<li><p><a href="#msflags.async" name="msflags.async"></a><strong><code>ASYNC</code></strong></p>

<p>Perform asynchronous writes.</p></li>
<li><p><a href="#msflags.invalidate" name="msflags.invalidate"></a><strong><code>INVALIDATE</code></strong></p>

<p>Invalidate cached data.</p></li>
<li><p><a href="#msflags.sync" name="msflags.sync"></a><strong><code>SYNC</code></strong></p>

<p>Perform synchronous writes.</p></li>
</ul>

<h4><a href="#nthreads" name="nthreads"></a><code>nthreads</code> (= <code>u32</code>)</h4>

<p>Specifies the number of threads sleeping on a condition
variable that should be woken up.</p>

<p>Used by <a href="#condvar_signal"><code>condvar_signal()</code></a>.</p>

<h4><a href="#oflags" name="oflags"></a><code>oflags</code> (<code>u16</code> bitfield)</h4>

<p>Open flags used by <a href="#file_open"><code>file_open()</code></a>.</p>

<p>Possible values:</p>

<ul>
<li><p><a href="#oflags.creat" name="oflags.creat"></a><strong><code>CREAT</code></strong></p>

<p>Create file if it does not exist.</p></li>
<li><p><a href="#oflags.directory" name="oflags.directory"></a><strong><code>DIRECTORY</code></strong></p>

<p>Fail if not a directory.</p></li>
<li><p><a href="#oflags.excl" name="oflags.excl"></a><strong><code>EXCL</code></strong></p>

<p>Fail if file already exists.</p></li>
<li><p><a href="#oflags.trunc" name="oflags.trunc"></a><strong><code>TRUNC</code></strong></p>

<p>Truncate file to size 0.</p></li>
</ul>

<h4><a href="#processentry" name="processentry"></a><code>processentry</code> (function pointer)</h4>

<p>Entry point for a process (<code>_start</code>).</p>

<p>Parameters:</p>

<ul>
<li><p><a href="#processentry.auxv" name="processentry.auxv"></a><code><strong>auxv</strong>: *const <a href="#auxv">auxv</a></code></p>

<p>The auxiliary vector. See <a href="#auxv"><code>auxv</code></a>.</p></li>
</ul>

<h4><a href="#recv_in" name="recv_in"></a><code>recv_in</code> (<code>struct</code>)</h4>

<p>Arguments of <a href="#sock_recv"><code>sock_recv()</code></a>.</p>

<p>Members:</p>

<ul>
<li><p><a href="#recv_in.ri_data" name="recv_in.ri_data"></a><code><strong>ri_data</strong>: *const <a href="#iovec">iovec</a></code> and <a href="#recv_in.ri_data_len" name="recv_in.ri_data_len"></a><code><strong>ri_data_len</strong>: usize</code></p>

<p>List of scatter/gather vectors where message data
should be stored.</p></li>
<li><p><a href="#recv_in.ri_fds" name="recv_in.ri_fds"></a><code><strong>ri_fds</strong>: *mut <a href="#fd">fd</a></code> and <a href="#recv_in.ri_fds_len" name="recv_in.ri_fds_len"></a><code><strong>ri_fds_len</strong>: usize</code></p>

<p>Buffer where numbers of incoming file descriptors
should be stored.</p></li>
<li><p><a href="#recv_in.ri_flags" name="recv_in.ri_flags"></a><code><strong>ri_flags</strong>: <a href="#riflags">riflags</a></code></p>

<p>Message flags.</p></li>
</ul>

<h4><a href="#recv_out" name="recv_out"></a><code>recv_out</code> (<code>struct</code>)</h4>

<p>Results of <a href="#sock_recv"><code>sock_recv()</code></a>.</p>

<p>Members:</p>

<ul>
<li><p><a href="#recv_out.ro_datalen" name="recv_out.ro_datalen"></a><code><strong>ro_datalen</strong>: usize</code></p>

<p>Number of bytes stored in <a href="#recv_in.ri_data"><code>recv_in.ri_data</code></a>.</p></li>
<li><p><a href="#recv_out.ro_fdslen" name="recv_out.ro_fdslen"></a><code><strong>ro_fdslen</strong>: usize</code></p>

<p>Number of file descriptors stored in <a href="#recv_in.ri_fds"><code>recv_in.ri_fds</code></a>.</p></li>
<li><p><a href="#recv_out.ro_unused" name="recv_out.ro_unused"></a><code><strong>ro_unused</strong>: [u8; 40]</code></p>

<p>Fields that were used by previous implementations.</p></li>
<li><p><a href="#recv_out.ro_flags" name="recv_out.ro_flags"></a><code><strong>ro_flags</strong>: <a href="#roflags">roflags</a></code></p>

<p>Message flags.</p></li>
</ul>

<h4><a href="#riflags" name="riflags"></a><code>riflags</code> (<code>u16</code> bitfield)</h4>

<p>Flags provided to <a href="#sock_recv"><code>sock_recv()</code></a>.</p>

<p>Used by <a href="#recv_in"><code>recv_in</code></a>.</p>

<p>Possible values:</p>

<ul>
<li><p><a href="#riflags.peek" name="riflags.peek"></a><strong><code>PEEK</code></strong></p>

<p>Returns the message without removing it from the
socket's receive queue.</p></li>
<li><p><a href="#riflags.waitall" name="riflags.waitall"></a><strong><code>WAITALL</code></strong></p>

<p>On byte-stream sockets, block until the full amount
of data can be returned.</p></li>
</ul>

<h4><a href="#rights" name="rights"></a><code>rights</code> (<code>u64</code> bitfield)</h4>

<p>File descriptor rights, determining which actions may be
performed.</p>

<p>Used by <a href="#fdstat"><code>fdstat</code></a>.</p>

<p>Possible values:</p>

<ul>
<li><p><a href="#rights.fd_datasync" name="rights.fd_datasync"></a><strong><code>FD_DATASYNC</code></strong></p>

<p>The right to invoke <a href="#fd_datasync"><code>fd_datasync()</code></a>.</p>

<p>If <a href="#rights.file_open"><code>FILE_OPEN</code></a> is set, includes the right to
invoke <a href="#file_open"><code>file_open()</code></a> with <a href="#fdflags.dsync"><code>DSYNC</code></a>.</p></li>
<li><p><a href="#rights.fd_read" name="rights.fd_read"></a><strong><code>FD_READ</code></strong></p>

<p>The right to invoke <a href="#fd_read"><code>fd_read()</code></a> and <a href="#sock_recv"><code>sock_recv()</code></a>.</p>

<p>If <a href="#rights.mem_map"><code>MEM_MAP</code></a> is set, includes the right to
invoke <a href="#mem_map"><code>mem_map()</code></a> with memory protection option
<a href="#mprot.read"><code>READ</code></a>.</p>

<p>If <a href="#rights.fd_seek"><code>FD_SEEK</code></a> is set, includes the right to invoke
<a href="#fd_pread"><code>fd_pread()</code></a>.</p></li>
<li><p><a href="#rights.fd_seek" name="rights.fd_seek"></a><strong><code>FD_SEEK</code></strong></p>

<p>The right to invoke <a href="#fd_seek"><code>fd_seek()</code></a>. This flag implies
<a href="#rights.fd_tell"><code>FD_TELL</code></a>.</p></li>
<li><p><a href="#rights.fd_stat_put_flags" name="rights.fd_stat_put_flags"></a><strong><code>FD_STAT_PUT_FLAGS</code></strong></p>

<p>The right to invoke <a href="#fd_stat_put"><code>fd_stat_put()</code></a> with
<a href="#fdsflags.flags"><code>FLAGS</code></a>.</p></li>
<li><p><a href="#rights.fd_sync" name="rights.fd_sync"></a><strong><code>FD_SYNC</code></strong></p>

<p>The right to invoke <a href="#fd_sync"><code>fd_sync()</code></a>.</p>

<p>If <a href="#rights.file_open"><code>FILE_OPEN</code></a> is set, includes the right to
invoke <a href="#file_open"><code>file_open()</code></a> with <a href="#fdflags.rsync"><code>RSYNC</code></a> and
<a href="#fdflags.dsync"><code>DSYNC</code></a>.</p></li>
<li><p><a href="#rights.fd_tell" name="rights.fd_tell"></a><strong><code>FD_TELL</code></strong></p>

<p>The right to invoke <a href="#fd_seek"><code>fd_seek()</code></a> in such a way that the
file offset remains unaltered (i.e., <a href="#whence.cur"><code>CUR</code></a> with
offset zero).</p></li>
<li><p><a href="#rights.fd_write" name="rights.fd_write"></a><strong><code>FD_WRITE</code></strong></p>

<p>The right to invoke <a href="#fd_write"><code>fd_write()</code></a> and <a href="#sock_send"><code>sock_send()</code></a>.</p>

<p>If <a href="#rights.mem_map"><code>MEM_MAP</code></a> is set, includes the right to
invoke <a href="#mem_map"><code>mem_map()</code></a> with memory protection option
<a href="#mprot.write"><code>WRITE</code></a>.</p>

<p>If <a href="#rights.fd_seek"><code>FD_SEEK</code></a> is set, includes the right to
invoke <a href="#fd_pwrite"><code>fd_pwrite()</code></a>.</p></li>
<li><p><a href="#rights.file_advise" name="rights.file_advise"></a><strong><code>FILE_ADVISE</code></strong></p>

<p>The right to invoke <a href="#file_advise"><code>file_advise()</code></a>.</p></li>
<li><p><a href="#rights.file_allocate" name="rights.file_allocate"></a><strong><code>FILE_ALLOCATE</code></strong></p>

<p>The right to invoke <a href="#file_allocate"><code>file_allocate()</code></a>.</p></li>
<li><p><a href="#rights.file_create_directory" name="rights.file_create_directory"></a><strong><code>FILE_CREATE_DIRECTORY</code></strong></p>

<p>The right to invoke <a href="#file_create"><code>file_create()</code></a> with
<a href="#filetype.directory"><code>DIRECTORY</code></a>.</p></li>
<li><p><a href="#rights.file_create_file" name="rights.file_create_file"></a><strong><code>FILE_CREATE_FILE</code></strong></p>

<p>If <a href="#rights.file_open"><code>FILE_OPEN</code></a> is set, the right to invoke
<a href="#file_open"><code>file_open()</code></a> with <a href="#oflags.creat"><code>CREAT</code></a>.</p></li>
<li><p><a href="#rights.file_link_source" name="rights.file_link_source"></a><strong><code>FILE_LINK_SOURCE</code></strong></p>

<p>The right to invoke <a href="#file_link"><code>file_link()</code></a> with the file
descriptor as the source directory.</p></li>
<li><p><a href="#rights.file_link_target" name="rights.file_link_target"></a><strong><code>FILE_LINK_TARGET</code></strong></p>

<p>The right to invoke <a href="#file_link"><code>file_link()</code></a> with the file
descriptor as the target directory.</p></li>
<li><p><a href="#rights.file_open" name="rights.file_open"></a><strong><code>FILE_OPEN</code></strong></p>

<p>The right to invoke <a href="#file_open"><code>file_open()</code></a>.</p></li>
<li><p><a href="#rights.file_readdir" name="rights.file_readdir"></a><strong><code>FILE_READDIR</code></strong></p>

<p>The right to invoke <a href="#file_readdir"><code>file_readdir()</code></a>.</p></li>
<li><p><a href="#rights.file_readlink" name="rights.file_readlink"></a><strong><code>FILE_READLINK</code></strong></p>

<p>The right to invoke <a href="#file_readlink"><code>file_readlink()</code></a>.</p></li>
<li><p><a href="#rights.file_rename_source" name="rights.file_rename_source"></a><strong><code>FILE_RENAME_SOURCE</code></strong></p>

<p>The right to invoke <a href="#file_rename"><code>file_rename()</code></a> with the file
descriptor as the source directory.</p></li>
<li><p><a href="#rights.file_rename_target" name="rights.file_rename_target"></a><strong><code>FILE_RENAME_TARGET</code></strong></p>

<p>The right to invoke <a href="#file_rename"><code>file_rename()</code></a> with the file
descriptor as the target directory.</p></li>
<li><p><a href="#rights.file_stat_fget" name="rights.file_stat_fget"></a><strong><code>FILE_STAT_FGET</code></strong></p>

<p>The right to invoke <a href="#file_stat_fget"><code>file_stat_fget()</code></a>.</p></li>
<li><p><a href="#rights.file_stat_fput_size" name="rights.file_stat_fput_size"></a><strong><code>FILE_STAT_FPUT_SIZE</code></strong></p>

<p>The right to invoke <a href="#file_stat_fput"><code>file_stat_fput()</code></a> with
<a href="#fsflags.size"><code>SIZE</code></a>.</p>

<p>If <a href="#rights.file_open"><code>FILE_OPEN</code></a> is set, includes the right to
invoke <a href="#file_open"><code>file_open()</code></a> with <a href="#oflags.trunc"><code>TRUNC</code></a>.</p></li>
<li><p><a href="#rights.file_stat_fput_times" name="rights.file_stat_fput_times"></a><strong><code>FILE_STAT_FPUT_TIMES</code></strong></p>

<p>The right to invoke <a href="#file_stat_fput"><code>file_stat_fput()</code></a> with
<a href="#fsflags.atim"><code>ATIM</code></a>, <a href="#fsflags.atim_now"><code>ATIM_NOW</code></a>, <a href="#fsflags.mtim"><code>MTIM</code></a>,
and <a href="#fsflags.mtim_now"><code>MTIM_NOW</code></a>.</p></li>
<li><p><a href="#rights.file_stat_get" name="rights.file_stat_get"></a><strong><code>FILE_STAT_GET</code></strong></p>

<p>The right to invoke <a href="#file_stat_get"><code>file_stat_get()</code></a>.</p></li>
<li><p><a href="#rights.file_stat_put_times" name="rights.file_stat_put_times"></a><strong><code>FILE_STAT_PUT_TIMES</code></strong></p>

<p>The right to invoke <a href="#file_stat_put"><code>file_stat_put()</code></a> with
<a href="#fsflags.atim"><code>ATIM</code></a>, <a href="#fsflags.atim_now"><code>ATIM_NOW</code></a>, <a href="#fsflags.mtim"><code>MTIM</code></a>,
and <a href="#fsflags.mtim_now"><code>MTIM_NOW</code></a>.</p></li>
<li><p><a href="#rights.file_symlink" name="rights.file_symlink"></a><strong><code>FILE_SYMLINK</code></strong></p>

<p>The right to invoke <a href="#file_symlink"><code>file_symlink()</code></a>.</p></li>
<li><p><a href="#rights.file_unlink" name="rights.file_unlink"></a><strong><code>FILE_UNLINK</code></strong></p>

<p>The right to invoke <a href="#file_unlink"><code>file_unlink()</code></a>.</p></li>
<li><p><a href="#rights.mem_map" name="rights.mem_map"></a><strong><code>MEM_MAP</code></strong></p>

<p>The right to invoke <a href="#mem_map"><code>mem_map()</code></a> with <a href="#mprot"><code>mprot</code></a> set to
zero.</p></li>
<li><p><a href="#rights.mem_map_exec" name="rights.mem_map_exec"></a><strong><code>MEM_MAP_EXEC</code></strong></p>

<p>If <a href="#rights.mem_map"><code>MEM_MAP</code></a> is set, the right to invoke
<a href="#mem_map"><code>mem_map()</code></a> with <a href="#mprot.exec"><code>EXEC</code></a>.</p></li>
<li><p><a href="#rights.poll_fd_readwrite" name="rights.poll_fd_readwrite"></a><strong><code>POLL_FD_READWRITE</code></strong></p>

<p>If <a href="#rights.fd_read"><code>FD_READ</code></a> is set, includes the right to
invoke <a href="#poll"><code>poll()</code></a> to subscribe to <a href="#eventtype.fd_read"><code>FD_READ</code></a>.</p>

<p>If <a href="#rights.fd_write"><code>FD_WRITE</code></a> is set, includes the right to
invoke <a href="#poll"><code>poll()</code></a> to subscribe to <a href="#eventtype.fd_write"><code>FD_WRITE</code></a>.</p></li>
<li><p><a href="#rights.poll_proc_terminate" name="rights.poll_proc_terminate"></a><strong><code>POLL_PROC_TERMINATE</code></strong></p>

<p>The right to invoke <a href="#poll"><code>poll()</code></a> to subscribe to
<a href="#eventtype.proc_terminate"><code>PROC_TERMINATE</code></a>.</p></li>
<li><p><a href="#rights.proc_exec" name="rights.proc_exec"></a><strong><code>PROC_EXEC</code></strong></p>

<p>The right to invoke <a href="#proc_exec"><code>proc_exec()</code></a>.</p></li>
<li><p><a href="#rights.sock_shutdown" name="rights.sock_shutdown"></a><strong><code>SOCK_SHUTDOWN</code></strong></p>

<p>The right to invoke <a href="#sock_shutdown"><code>sock_shutdown()</code></a>.</p></li>
</ul>

<h4><a href="#roflags" name="roflags"></a><code>roflags</code> (<code>u16</code> bitfield)</h4>

<p>Flags returned by <a href="#sock_recv"><code>sock_recv()</code></a>.</p>

<p>Used by <a href="#recv_out"><code>recv_out</code></a>.</p>

<p>Possible values:</p>

<ul>
<li><p><a href="#roflags.fds_truncated" name="roflags.fds_truncated"></a><strong><code>FDS_TRUNCATED</code></strong></p>

<p>Returned by <a href="#sock_recv"><code>sock_recv()</code></a>: List of file descriptors
has been truncated.</p></li>
<li><p><a href="#roflags.data_truncated" name="roflags.data_truncated"></a><strong><code>DATA_TRUNCATED</code></strong></p>

<p>Returned by <a href="#sock_recv"><code>sock_recv()</code></a>: Message data has been
truncated.</p></li>
</ul>

<h4><a href="#scope" name="scope"></a><code>scope</code> (<code>u8</code> <code>enum</code>)</h4>

<p>Indicates whether an object is stored in private or shared
memory.</p>

<p>Used by <a href="#subscription"><code>subscription</code></a>, <a href="#condvar_signal"><code>condvar_signal()</code></a>, <a href="#lock_unlock"><code>lock_unlock()</code></a>, and <a href="#thread_exit"><code>thread_exit()</code></a>.</p>

<p>Possible values:</p>

<ul>
<li><p><a href="#scope.private" name="scope.private"></a><strong><code>PRIVATE</code></strong></p>

<p>The object is stored in private memory.</p></li>
<li><p><a href="#scope.shared" name="scope.shared"></a><strong><code>SHARED</code></strong></p>

<p>The object is stored in shared memory.</p></li>
</ul>

<h4><a href="#sdflags" name="sdflags"></a><code>sdflags</code> (<code>u8</code> bitfield)</h4>

<p>Which channels on a socket need to be shut down.</p>

<p>Used by <a href="#sock_shutdown"><code>sock_shutdown()</code></a>.</p>

<p>Possible values:</p>

<ul>
<li><p><a href="#sdflags.rd" name="sdflags.rd"></a><strong><code>RD</code></strong></p>

<p>Disables further receive operations.</p></li>
<li><p><a href="#sdflags.wr" name="sdflags.wr"></a><strong><code>WR</code></strong></p>

<p>Disables further send operations.</p></li>
</ul>

<h4><a href="#send_in" name="send_in"></a><code>send_in</code> (<code>struct</code>)</h4>

<p>Arguments of <a href="#sock_send"><code>sock_send()</code></a>.</p>

<p>Members:</p>

<ul>
<li><p><a href="#send_in.si_data" name="send_in.si_data"></a><code><strong>si_data</strong>: *const <a href="#ciovec">ciovec</a></code> and <a href="#send_in.si_data_len" name="send_in.si_data_len"></a><code><strong>si_data_len</strong>: usize</code></p>

<p>List of scatter/gather vectors where message data
should be retrieved.</p></li>
<li><p><a href="#send_in.si_fds" name="send_in.si_fds"></a><code><strong>si_fds</strong>: *const <a href="#fd">fd</a></code> and <a href="#send_in.si_fds_len" name="send_in.si_fds_len"></a><code><strong>si_fds_len</strong>: usize</code></p>

<p>File descriptors that need to be attached to the
message.</p></li>
<li><p><a href="#send_in.si_flags" name="send_in.si_flags"></a><code><strong>si_flags</strong>: <a href="#siflags">siflags</a></code></p>

<p>Message flags.</p></li>
</ul>

<h4><a href="#send_out" name="send_out"></a><code>send_out</code> (<code>struct</code>)</h4>

<p>Results of <a href="#sock_send"><code>sock_send()</code></a>.</p>

<p>Members:</p>

<ul>
<li><p><a href="#send_out.so_datalen" name="send_out.so_datalen"></a><code><strong>so_datalen</strong>: usize</code></p>

<p>Number of bytes transmitted.</p></li>
</ul>

<h4><a href="#siflags" name="siflags"></a><code>siflags</code> (<code>u16</code> bitfield)</h4>

<p>Flags provided to <a href="#sock_send"><code>sock_send()</code></a>. As there are currently no flags
defined, it must be set to zero.</p>

<p>Used by <a href="#send_in"><code>send_in</code></a>.</p>

<h4><a href="#signal" name="signal"></a><code>signal</code> (<code>u8</code> <code>enum</code>)</h4>

<p>Signal condition.</p>

<p>Used by <a href="#event"><code>event</code></a> and <a href="#proc_raise"><code>proc_raise()</code></a>.</p>

<p>Possible values:</p>

<ul>
<li><p><a href="#signal.abrt" name="signal.abrt"></a><strong><code>ABRT</code></strong></p>

<p>Process abort signal.</p>

<p>Action: Terminates the process.</p></li>
<li><p><a href="#signal.alrm" name="signal.alrm"></a><strong><code>ALRM</code></strong></p>

<p>Alarm clock.</p>

<p>Action: Terminates the process.</p></li>
<li><p><a href="#signal.bus" name="signal.bus"></a><strong><code>BUS</code></strong></p>

<p>Access to an undefined portion of a memory object.</p>

<p>Action: Terminates the process.</p></li>
<li><p><a href="#signal.chld" name="signal.chld"></a><strong><code>CHLD</code></strong></p>

<p>Child process terminated, stopped, or continued.</p>

<p>Action: Ignored.</p></li>
<li><p><a href="#signal.cont" name="signal.cont"></a><strong><code>CONT</code></strong></p>

<p>Continue executing, if stopped.</p>

<p>Action: Continues executing, if stopped.</p></li>
<li><p><a href="#signal.fpe" name="signal.fpe"></a><strong><code>FPE</code></strong></p>

<p>Erroneous arithmetic operation.</p>

<p>Action: Terminates the process.</p></li>
<li><p><a href="#signal.hup" name="signal.hup"></a><strong><code>HUP</code></strong></p>

<p>Hangup.</p>

<p>Action: Terminates the process.</p></li>
<li><p><a href="#signal.ill" name="signal.ill"></a><strong><code>ILL</code></strong></p>

<p>Illegal instruction.</p>

<p>Action: Terminates the process.</p></li>
<li><p><a href="#signal.int" name="signal.int"></a><strong><code>INT</code></strong></p>

<p>Terminate interrupt signal.</p>

<p>Action: Terminates the process.</p></li>
<li><p><a href="#signal.kill" name="signal.kill"></a><strong><code>KILL</code></strong></p>

<p>Kill.</p>

<p>Action: Terminates the process.</p></li>
<li><p><a href="#signal.pipe" name="signal.pipe"></a><strong><code>PIPE</code></strong></p>

<p>Write on a pipe with no one to read it.</p>

<p>Action: Ignored.</p></li>
<li><p><a href="#signal.quit" name="signal.quit"></a><strong><code>QUIT</code></strong></p>

<p>Terminal quit signal.</p>

<p>Action: Terminates the process.</p></li>
<li><p><a href="#signal.segv" name="signal.segv"></a><strong><code>SEGV</code></strong></p>

<p>Invalid memory reference.</p>

<p>Action: Terminates the process.</p></li>
<li><p><a href="#signal.stop" name="signal.stop"></a><strong><code>STOP</code></strong></p>

<p>Stop executing.</p>

<p>Action: Stops executing.</p></li>
<li><p><a href="#signal.sys" name="signal.sys"></a><strong><code>SYS</code></strong></p>

<p>Bad system call.</p>

<p>Action: Terminates the process.</p></li>
<li><p><a href="#signal.term" name="signal.term"></a><strong><code>TERM</code></strong></p>

<p>Termination signal.</p>

<p>Action: Terminates the process.</p></li>
<li><p><a href="#signal.trap" name="signal.trap"></a><strong><code>TRAP</code></strong></p>

<p>Trace/breakpoint trap.</p>

<p>Action: Terminates the process.</p></li>
<li><p><a href="#signal.tstp" name="signal.tstp"></a><strong><code>TSTP</code></strong></p>

<p>Terminal stop signal.</p>

<p>Action: Stops executing.</p></li>
<li><p><a href="#signal.ttin" name="signal.ttin"></a><strong><code>TTIN</code></strong></p>

<p>Background process attempting read.</p>

<p>Action: Stops executing.</p></li>
<li><p><a href="#signal.ttou" name="signal.ttou"></a><strong><code>TTOU</code></strong></p>

<p>Background process attempting write.</p>

<p>Action: Stops executing.</p></li>
<li><p><a href="#signal.urg" name="signal.urg"></a><strong><code>URG</code></strong></p>

<p>High bandwidth data is available at a socket.</p>

<p>Action: Ignored.</p></li>
<li><p><a href="#signal.usr1" name="signal.usr1"></a><strong><code>USR1</code></strong></p>

<p>User-defined signal 1.</p>

<p>Action: Terminates the process.</p></li>
<li><p><a href="#signal.usr2" name="signal.usr2"></a><strong><code>USR2</code></strong></p>

<p>User-defined signal 2.</p>

<p>Action: Terminates the process.</p></li>
<li><p><a href="#signal.vtalrm" name="signal.vtalrm"></a><strong><code>VTALRM</code></strong></p>

<p>Virtual timer expired.</p>

<p>Action: Terminates the process.</p></li>
<li><p><a href="#signal.xcpu" name="signal.xcpu"></a><strong><code>XCPU</code></strong></p>

<p>CPU time limit exceeded.</p>

<p>Action: Terminates the process.</p></li>
<li><p><a href="#signal.xfsz" name="signal.xfsz"></a><strong><code>XFSZ</code></strong></p>

<p>File size limit exceeded.</p>

<p>Action: Terminates the process.</p></li>
</ul>

<h4><a href="#subclockflags" name="subclockflags"></a><code>subclockflags</code> (<code>u16</code> bitfield)</h4>

<p>Flags determining how the timestamp provided in
<a href="#subscription.clock.timeout"><code>subscription.union.clock.timeout</code></a> should be interpreted.</p>

<p>Used by <a href="#subscription"><code>subscription</code></a>.</p>

<p>Possible values:</p>

<ul>
<li><p><a href="#subclockflags.abstime" name="subclockflags.abstime"></a><strong><code>ABSTIME</code></strong></p>

<p>If set, treat the timestamp provided in
<a href="#subscription.clock.timeout"><code>subscription.union.clock.timeout</code></a> as an absolute timestamp
of clock <a href="#subscription.clock.clock_id"><code>subscription.union.clock.clock_id</code></a>.</p>

<p>If clear, treat the timestamp provided in
<a href="#subscription.clock.timeout"><code>subscription.union.clock.timeout</code></a> relative to the current
time value of clock <a href="#subscription.clock.clock_id"><code>subscription.union.clock.clock_id</code></a>.</p></li>
</ul>

<h4><a href="#subrwflags" name="subrwflags"></a><code>subrwflags</code> (<code>u16</code> bitfield)</h4>

<p>Flags influencing the method of polling for read or writing on
a file descriptor.</p>

<p>Used by <a href="#subscription"><code>subscription</code></a>.</p>

<p>Possible values:</p>

<ul>
<li><p><a href="#subrwflags.poll" name="subrwflags.poll"></a><strong><code>POLL</code></strong></p>

<p>Deprecated. Must be set by callers and ignored by
implementations.</p></li>
</ul>

<h4><a href="#subscription" name="subscription"></a><code>subscription</code> (<code>struct</code>)</h4>

<p>Subscription to an event.</p>

<p>Used by <a href="#poll"><code>poll()</code></a>.</p>

<p>Members:</p>

<ul>
<li><p><a href="#subscription.userdata" name="subscription.userdata"></a><code><strong>userdata</strong>: <a href="#userdata">userdata</a></code></p>

<p>User-provided value that is attached to the
subscription in the kernel and returned through
<a href="#event.userdata"><code>event.userdata</code></a>.</p></li>
<li><p><a href="#subscription.unused" name="subscription.unused"></a><code><strong>unused</strong>: u16</code></p>

<p>Used by previous implementations. Ignored.</p></li>
<li><p><a href="#subscription.type" name="subscription.type"></a><code><strong>r#type</strong>: <a href="#eventtype">eventtype</a></code></p>

<p>The type of the event to which to subscribe.</p>

<p>Currently, <a href="#eventtype.condvar"><code>CONDVAR</code></a>,
<a href="#eventtype.lock_rdlock"><code>LOCK_RDLOCK</code></a>, and <a href="#eventtype.lock_wrlock"><code>LOCK_WRLOCK</code></a>
must be provided as the first subscription and may
only be followed by up to one other subscription,
having type <a href="#eventtype.clock"><code>CLOCK</code></a>.</p></li>
<li><p>When <code>type</code> is <a href="#eventtype.clock"><code>CLOCK</code></a>:</p>

<ul>
<li><p><a href="#subscription.clock" name="subscription.clock"></a><strong><code>union.clock</code></strong></p>

<ul>
<li><p><a href="#subscription.clock.identifier" name="subscription.clock.identifier"></a><code><strong>identifier</strong>: <a href="#userdata">userdata</a></code></p>

<p>The user-defined unique
identifier of the clock.</p></li>
<li><p><a href="#subscription.clock.clock_id" name="subscription.clock.clock_id"></a><code><strong>clock_id</strong>: <a href="#clockid">clockid</a></code></p>

<p>The clock against which the
timestamp should be compared.</p></li>
<li><p><a href="#subscription.clock.timeout" name="subscription.clock.timeout"></a><code><strong>timeout</strong>: <a href="#timestamp">timestamp</a></code></p>

<p>The absolute or relative
timestamp.</p></li>
<li><p><a href="#subscription.clock.precision" name="subscription.clock.precision"></a><code><strong>precision</strong>: <a href="#timestamp">timestamp</a></code></p>

<p>The amount of time that the
kernel may wait additionally
to coalesce with other events.</p></li>
<li><p><a href="#subscription.clock.flags" name="subscription.clock.flags"></a><code><strong>flags</strong>: <a href="#subclockflags">subclockflags</a></code></p>

<p>Flags specifying whether the
timeout is absolute or
relative.</p></li>
</ul></li>
</ul></li>
<li><p>When <code>type</code> is <a href="#eventtype.condvar"><code>CONDVAR</code></a>:</p>

<ul>
<li><p><a href="#subscription.condvar" name="subscription.condvar"></a><strong><code>union.condvar</code></strong></p>

<ul>
<li><p><a href="#subscription.condvar.condvar" name="subscription.condvar.condvar"></a><code><strong>condvar</strong>: *mut <a href="#condvar">condvar</a></code></p>

<p>The condition variable on
which to wait to be woken up.</p></li>
<li><p><a href="#subscription.condvar.lock" name="subscription.condvar.lock"></a><code><strong>lock</strong>: *mut <a href="#lock">lock</a></code></p>

<p>The lock that will be
released while waiting.</p>

<p>The lock will be reacquired
for writing when the condition
variable triggers.</p></li>
<li><p><a href="#subscription.condvar.condvar_scope" name="subscription.condvar.condvar_scope"></a><code><strong>condvar_scope</strong>: <a href="#scope">scope</a></code></p>

<p>Whether the condition variable
is stored in private or shared
memory.</p></li>
<li><p><a href="#subscription.condvar.lock_scope" name="subscription.condvar.lock_scope"></a><code><strong>lock_scope</strong>: <a href="#scope">scope</a></code></p>

<p>Whether the lock is stored in
private or shared memory.</p></li>
</ul></li>
</ul></li>
<li><p>When <code>type</code> is <a href="#eventtype.fd_read"><code>FD_READ</code></a> or <a href="#eventtype.fd_write"><code>FD_WRITE</code></a>:</p>

<ul>
<li><p><a href="#subscription.fd_readwrite" name="subscription.fd_readwrite"></a><strong><code>union.fd_readwrite</code></strong></p>

<ul>
<li><p><a href="#subscription.fd_readwrite.fd" name="subscription.fd_readwrite.fd"></a><code><strong>fd</strong>: <a href="#fd">fd</a></code></p>

<p>The file descriptor on which
to wait for it to become ready
for reading or writing.</p></li>
<li><p><a href="#subscription.fd_readwrite.flags" name="subscription.fd_readwrite.flags"></a><code><strong>flags</strong>: <a href="#subrwflags">subrwflags</a></code></p>

<p>Under which conditions to
trigger.</p></li>
</ul></li>
</ul></li>
<li><p>When <code>type</code> is <a href="#eventtype.lock_rdlock"><code>LOCK_RDLOCK</code></a> or <a href="#eventtype.lock_wrlock"><code>LOCK_WRLOCK</code></a>:</p>

<ul>
<li><p><a href="#subscription.lock" name="subscription.lock"></a><strong><code>union.lock</code></strong></p>

<ul>
<li><p><a href="#subscription.lock.lock" name="subscription.lock.lock"></a><code><strong>lock</strong>: *mut <a href="#lock">lock</a></code></p>

<p>The lock that will be acquired
for reading or writing.</p></li>
<li><p><a href="#subscription.lock.lock_scope" name="subscription.lock.lock_scope"></a><code><strong>lock_scope</strong>: <a href="#scope">scope</a></code></p>

<p>Whether the lock is stored in
private or shared memory.</p></li>
</ul></li>
</ul></li>
<li><p>When <code>type</code> is <a href="#eventtype.proc_terminate"><code>PROC_TERMINATE</code></a>:</p>

<ul>
<li><p><a href="#subscription.proc_terminate" name="subscription.proc_terminate"></a><strong><code>union.proc_terminate</code></strong></p>

<ul>
<li><p><a href="#subscription.proc_terminate.fd" name="subscription.proc_terminate.fd"></a><code><strong>fd</strong>: <a href="#fd">fd</a></code></p>

<p>The process descriptor on
which to wait for process
termination.</p></li>
</ul></li>
</ul></li>
</ul>

<h4><a href="#tcb" name="tcb"></a><code>tcb</code> (<code>struct</code>)</h4>

<p>The Thread Control Block (TCB).</p>

<p>After a thread begins execution (at program startup or when
created through <a href="#thread_create"><code>thread_create()</code></a>), the CPU's registers
controlling Thread-Local Storage (TLS) will already be
initialized. They will point to an area only containing the
TCB.</p>

<p>If the thread needs space for storing thread-specific
variables, the thread may allocate a larger area and adjust
the CPU's registers to point to that area instead. However, it
does need to make sure that the TCB is copied over to the new
TLS area.</p>

<p>The purpose of the TCB is that it allows light-weight
emulators to store information related to individual threads.
For example, it may be used to store a copy of the CPU
registers prior emulation, so that TLS for the host system
can be restored if needed.</p>

<p>Members:</p>

<ul>
<li><p><a href="#tcb.parent" name="tcb.parent"></a><code><strong>parent</strong>: *mut ()</code></p>

<p>Pointer that may be freely assigned by the system. Its
value cannot be interpreted by the application.</p></li>
</ul>

<h4><a href="#threadattr" name="threadattr"></a><code>threadattr</code> (<code>struct</code>)</h4>

<p>Attributes for thread creation.</p>

<p>Used by <a href="#thread_create"><code>thread_create()</code></a>.</p>

<p>Members:</p>

<ul>
<li><p><a href="#threadattr.entry_point" name="threadattr.entry_point"></a><code><strong>entry_point</strong>: <a href="#threadentry">threadentry</a></code></p>

<p>Initial program counter value.</p></li>
<li><p><a href="#threadattr.stack" name="threadattr.stack"></a><code><strong>stack</strong>: *mut ()</code> and <a href="#threadattr.stack_len" name="threadattr.stack_len"></a><code><strong>stack_len</strong>: usize</code></p>

<p>Region allocated to serve as stack space.</p></li>
<li><p><a href="#threadattr.argument" name="threadattr.argument"></a><code><strong>argument</strong>: *mut ()</code></p>

<p>Argument to be forwarded to the entry point function.</p></li>
</ul>

<h4><a href="#threadentry" name="threadentry"></a><code>threadentry</code> (function pointer)</h4>

<p>Entry point for additionally created threads.</p>

<p>Used by <a href="#threadattr"><code>threadattr</code></a>.</p>

<p>Parameters:</p>

<ul>
<li><p><a href="#threadentry.tid" name="threadentry.tid"></a><code><strong>tid</strong>: <a href="#tid">tid</a></code></p>

<p>Thread ID of the current thread.</p></li>
<li><p><a href="#threadentry.aux" name="threadentry.aux"></a><code><strong>aux</strong>: *mut ()</code></p>

<p>Copy of the value stored in
<a href="#threadattr.argument"><code>threadattr.argument</code></a>.</p></li>
</ul>

<h4><a href="#tid" name="tid"></a><code>tid</code> (<code>struct(u32)</code>)</h4>

<p>Unique system-local identifier of a thread. This identifier is
only valid during the lifetime of the thread.</p>

<p>Threads must be aware of their thread identifier, as it is
written it into locks when acquiring them for writing. It is
not advised to use these identifiers for any other purpose.</p>

<p>As the thread identifier is also stored in <a href="#lock"><code>lock</code></a> when
<a href="#lock.wrlocked"><code>LOCK_WRLOCKED</code></a> is set, the top two bits of the thread
must always be set to zero.</p>

<p>Used by <a href="#threadentry"><code>threadentry</code></a>, <a href="#proc_fork"><code>proc_fork()</code></a>, and <a href="#thread_create"><code>thread_create()</code></a>.</p>

<h4><a href="#timestamp" name="timestamp"></a><code>timestamp</code> (= <code>u64</code>)</h4>

<p>Timestamp in nanoseconds.</p>

<p>Used by <a href="#filestat"><code>filestat</code></a>, <a href="#subscription"><code>subscription</code></a>, <a href="#clock_res_get"><code>clock_res_get()</code></a>, and <a href="#clock_time_get"><code>clock_time_get()</code></a>.</p>

<h4><a href="#ulflags" name="ulflags"></a><code>ulflags</code> (<code>u8</code> bitfield)</h4>

<p>Specifies whether files are unlinked or directories are
removed.</p>

<p>Used by <a href="#file_unlink"><code>file_unlink()</code></a>.</p>

<p>Possible values:</p>

<ul>
<li><p><a href="#ulflags.removedir" name="ulflags.removedir"></a><strong><code>REMOVEDIR</code></strong></p>

<p>If set, removes a directory. Otherwise, unlinks any
non-directory file.</p></li>
</ul>

<h4><a href="#userdata" name="userdata"></a><code>userdata</code> (= <code>u64</code>)</h4>

<p>User-provided value that can be attached to objects that is
retained when extracted from the kernel.</p>

<p>Used by <a href="#event"><code>event</code></a> and <a href="#subscription"><code>subscription</code></a>.</p>

<h4><a href="#whence" name="whence"></a><code>whence</code> (<code>u8</code> <code>enum</code>)</h4>

<p>Relative to which position the offset of the file descriptor
should be set.</p>

<p>Used by <a href="#fd_seek"><code>fd_seek()</code></a>.</p>

<p>Possible values:</p>

<ul>
<li><p><a href="#whence.cur" name="whence.cur"></a><strong><code>CUR</code></strong></p>

<p>Seek relative to current position.</p></li>
<li><p><a href="#whence.end" name="whence.end"></a><strong><code>END</code></strong></p>

<p>Seek relative to end-of-file.</p></li>
<li><p><a href="#whence.set" name="whence.set"></a><strong><code>SET</code></strong></p>

<p>Seek relative to start-of-file.</p></li>
</ul>
		</div>
	</body>
</html>
